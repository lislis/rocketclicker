import{a2 as q,a3 as K,j as vt,E as R,U as zs,T as Ke,v as Gs,k as ot,a4 as Q,a5 as Gt,a6 as O,P as gt,D as Us,a7 as W,a8 as Es,a9 as H,aa as Br,ab as V,ac as E,ad as D,ae as Ds,af as bt,ag as Qt,C as Ws,ah as X,ai as Ls,aj as Zt,ak as Hs,al as Se,l as N}from"./index.js";const Jt=Object.create(null),Qe=Object.create(null);function Be(i,t){let e=Qe[i];return e===void 0&&(Jt[t]===void 0&&(Jt[t]=1),Qe[i]=e=Jt[t]++),e}let xt;function Ar(){return(!xt||xt!=null&&xt.isContextLost())&&(xt=q.get().createCanvas().getContext("webgl",{})),xt}let Wt;function Os(){if(!Wt){Wt="mediump";const i=Ar();i&&i.getShaderPrecisionFormat&&(Wt=i.getShaderPrecisionFormat(i.FRAGMENT_SHADER,i.HIGH_FLOAT).precision?"highp":"mediump")}return Wt}function $s(i,t,e){return t?i:e?(i=i.replace("out vec4 finalColor;",""),`
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${i}
        `):`
        
        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${i}
        `}function Vs(i,t,e){const r=e?t.maxSupportedFragmentPrecision:t.maxSupportedVertexPrecision;if(i.substring(0,9)!=="precision"){let s=e?t.requestedFragmentPrecision:t.requestedVertexPrecision;return s==="highp"&&r!=="highp"&&(s="mediump"),`precision ${s} float;
${i}`}else if(r!=="highp"&&i.substring(0,15)==="precision highp")return i.replace("precision highp","precision mediump");return i}function Ns(i,t){return t?`#version 300 es
${i}`:i}const js={},Ys={};function Xs(i,{name:t="pixi-program"},e=!0){t=t.replace(/\s+/g,"-"),t+=e?"-fragment":"-vertex";const r=e?js:Ys;return r[t]?(r[t]++,t+=`-${r[t]}`):r[t]=1,i.indexOf("#define SHADER_NAME")!==-1?i:`${`#define SHADER_NAME ${t}`}
${i}`}function qs(i,t){return t?i.replace("#version 300 es",""):i}const te={stripVersion:qs,ensurePrecision:Vs,addProgramDefines:$s,setProgramName:Xs,insertVersion:Ns},ee=Object.create(null),Fr=class we{constructor(t){t={...we.defaultOptions,...t};const e=t.fragment.indexOf("#version 300 es")!==-1,r={stripVersion:e,ensurePrecision:{requestedFragmentPrecision:t.preferredFragmentPrecision,requestedVertexPrecision:t.preferredVertexPrecision,maxSupportedVertexPrecision:"highp",maxSupportedFragmentPrecision:Os()},setProgramName:{name:t.name},addProgramDefines:e,insertVersion:e};let s=t.fragment,n=t.vertex;Object.keys(te).forEach(a=>{const o=r[a];s=te[a](s,o,!0),n=te[a](n,o,!1)}),this.fragment=s,this.vertex=n,this._key=Be(`${this.vertex}:${this.fragment}`,"gl-program")}destroy(){this.fragment=null,this.vertex=null,this._attributeData=null,this._uniformData=null,this._uniformBlockData=null,this.transformFeedbackVaryings=null}static from(t){const e=`${t.vertex}:${t.fragment}`;return ee[e]||(ee[e]=new we(t)),ee[e]}};Fr.defaultOptions={preferredVertexPrecision:"highp",preferredFragmentPrecision:"mediump"};let Rr=Fr;const Ze={uint8x2:{size:2,stride:2,normalised:!1},uint8x4:{size:4,stride:4,normalised:!1},sint8x2:{size:2,stride:2,normalised:!1},sint8x4:{size:4,stride:4,normalised:!1},unorm8x2:{size:2,stride:2,normalised:!0},unorm8x4:{size:4,stride:4,normalised:!0},snorm8x2:{size:2,stride:2,normalised:!0},snorm8x4:{size:4,stride:4,normalised:!0},uint16x2:{size:2,stride:4,normalised:!1},uint16x4:{size:4,stride:8,normalised:!1},sint16x2:{size:2,stride:4,normalised:!1},sint16x4:{size:4,stride:8,normalised:!1},unorm16x2:{size:2,stride:4,normalised:!0},unorm16x4:{size:4,stride:8,normalised:!0},snorm16x2:{size:2,stride:4,normalised:!0},snorm16x4:{size:4,stride:8,normalised:!0},float16x2:{size:2,stride:4,normalised:!1},float16x4:{size:4,stride:8,normalised:!1},float32:{size:1,stride:4,normalised:!1},float32x2:{size:2,stride:8,normalised:!1},float32x3:{size:3,stride:12,normalised:!1},float32x4:{size:4,stride:16,normalised:!1},uint32:{size:1,stride:4,normalised:!1},uint32x2:{size:2,stride:8,normalised:!1},uint32x3:{size:3,stride:12,normalised:!1},uint32x4:{size:4,stride:16,normalised:!1},sint32:{size:1,stride:4,normalised:!1},sint32x2:{size:2,stride:8,normalised:!1},sint32x3:{size:3,stride:12,normalised:!1},sint32x4:{size:4,stride:16,normalised:!1}};function Ks(i){return Ze[i]??Ze.float32}const Qs={f32:"float32","vec2<f32>":"float32x2","vec3<f32>":"float32x3","vec4<f32>":"float32x4",vec2f:"float32x2",vec3f:"float32x3",vec4f:"float32x4",i32:"sint32","vec2<i32>":"sint32x2","vec3<i32>":"sint32x3","vec4<i32>":"sint32x4",u32:"uint32","vec2<u32>":"uint32x2","vec3<u32>":"uint32x3","vec4<u32>":"uint32x4",bool:"uint32","vec2<bool>":"uint32x2","vec3<bool>":"uint32x3","vec4<bool>":"uint32x4"};function Zs({source:i,entryPoint:t}){const e={},r=i.indexOf(`fn ${t}`);if(r!==-1){const s=i.indexOf("->",r);if(s!==-1){const n=i.substring(r,s),a=/@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;let o;for(;(o=a.exec(n))!==null;){const h=Qs[o[3]]??"float32";e[o[2]]={location:parseInt(o[1],10),format:h,stride:Ks(h).stride,offset:0,instance:!1,start:0}}}}return e}function re(i){var u,f;const t=/(^|[^/])@(group|binding)\(\d+\)[^;]+;/g,e=/@group\((\d+)\)/,r=/@binding\((\d+)\)/,s=/var(<[^>]+>)? (\w+)/,n=/:\s*(\w+)/,a=/struct\s+(\w+)\s*{([^}]+)}/g,o=/(\w+)\s*:\s*([\w\<\>]+)/g,h=/struct\s+(\w+)/,l=(u=i.match(t))==null?void 0:u.map(p=>({group:parseInt(p.match(e)[1],10),binding:parseInt(p.match(r)[1],10),name:p.match(s)[2],isUniform:p.match(s)[1]==="<uniform>",type:p.match(n)[1]}));if(!l)return{groups:[],structs:[]};const c=((f=i.match(a))==null?void 0:f.map(p=>{const d=p.match(h)[1],x=p.match(o).reduce((g,_)=>{const[m,y]=_.split(":");return g[m.trim()]=y.trim(),g},{});return x?{name:d,members:x}:null}).filter(({name:p})=>l.some(d=>d.type===p)))??[];return{groups:l,structs:c}}var Rt=(i=>(i[i.VERTEX=1]="VERTEX",i[i.FRAGMENT=2]="FRAGMENT",i[i.COMPUTE=4]="COMPUTE",i))(Rt||{});function Js({groups:i}){const t=[];for(let e=0;e<i.length;e++){const r=i[e];t[r.group]||(t[r.group]=[]),r.isUniform?t[r.group].push({binding:r.binding,visibility:Rt.VERTEX|Rt.FRAGMENT,buffer:{type:"uniform"}}):r.type==="sampler"?t[r.group].push({binding:r.binding,visibility:Rt.FRAGMENT,sampler:{type:"filtering"}}):r.type==="texture_2d"&&t[r.group].push({binding:r.binding,visibility:Rt.FRAGMENT,texture:{sampleType:"float",viewDimension:"2d",multisampled:!1}})}return t}function ti({groups:i}){const t=[];for(let e=0;e<i.length;e++){const r=i[e];t[r.group]||(t[r.group]={}),t[r.group][r.name]=r.binding}return t}function ei(i,t){const e=new Set,r=new Set,s=[...i.structs,...t.structs].filter(a=>e.has(a.name)?!1:(e.add(a.name),!0)),n=[...i.groups,...t.groups].filter(a=>{const o=`${a.name}-${a.binding}`;return r.has(o)?!1:(r.add(o),!0)});return{structs:s,groups:n}}const se=Object.create(null);class Xt{constructor(t){var o,h;this._layoutKey=0;const{fragment:e,vertex:r,layout:s,gpuLayout:n,name:a}=t;if(this.name=a,this.fragment=e,this.vertex=r,e.source===r.source){const l=re(e.source);this.structsAndGroups=l}else{const l=re(r.source),c=re(e.source);this.structsAndGroups=ei(l,c)}this.layout=s??ti(this.structsAndGroups),this.gpuLayout=n??Js(this.structsAndGroups),this.autoAssignGlobalUniforms=((o=this.layout[0])==null?void 0:o.globalUniforms)!==void 0,this.autoAssignLocalUniforms=((h=this.layout[1])==null?void 0:h.localUniforms)!==void 0,this._generateProgramKey()}_generateProgramKey(){const{vertex:t,fragment:e}=this,r=t.source+e.source+t.entryPoint+e.entryPoint;this._layoutKey=Be(r,"program")}get attributeData(){return this._attributeData??(this._attributeData=Zs(this.vertex)),this._attributeData}destroy(){this.gpuLayout=null,this.layout=null,this.structsAndGroups=null,this.fragment=null,this.vertex=null}static from(t){const e=`${t.vertex.source}:${t.fragment.source}:${t.fragment.entryPoint}:${t.vertex.entryPoint}`;return se[e]||(se[e]=new Xt(t)),se[e]}}function ri(i,t){switch(i){case"f32":return 0;case"vec2<f32>":return new Float32Array(2*t);case"vec3<f32>":return new Float32Array(3*t);case"vec4<f32>":return new Float32Array(4*t);case"mat2x2<f32>":return new Float32Array([1,0,0,1]);case"mat3x3<f32>":return new Float32Array([1,0,0,0,1,0,0,0,1]);case"mat4x4<f32>":return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}return null}const Ir=class zr{constructor(t,e){this._touched=0,this.uid=K("uniform"),this._resourceType="uniformGroup",this._resourceId=K("resource"),this.isUniformGroup=!0,this._dirtyId=0,this.destroyed=!1,e={...zr.defaultOptions,...e},this.uniformStructures=t;const r={};for(const s in t){const n=t[s];n.name=s,n.size=n.size??1,n.value??(n.value=ri(n.type,n.size)),r[s]=n.value}this.uniforms=r,this._dirtyId=1,this.ubo=e.ubo,this.isStatic=e.isStatic,this._signature=Be(Object.keys(r).map(s=>`${s}-${t[s].type}`).join("-"),"uniform-group")}update(){this._dirtyId++}};Ir.defaultOptions={ubo:!1,isStatic:!1};let mt=Ir;class yt{constructor(t){this.resources=Object.create(null),this._dirty=!0;let e=0;for(const r in t){const s=t[r];this.setResource(s,e++)}this._updateKey()}_updateKey(){if(!this._dirty)return;this._dirty=!1;const t=[];let e=0;for(const r in this.resources)t[e++]=this.resources[r]._resourceId;this._key=t.join("|")}setResource(t,e){var s,n;const r=this.resources[e];t!==r&&(r&&((s=t.off)==null||s.call(t,"change",this.onResourceChange,this)),(n=t.on)==null||n.call(t,"change",this.onResourceChange,this),this.resources[e]=t,this._dirty=!0)}getResource(t){return this.resources[t]}_touch(t){const e=this.resources;for(const r in e)e[r]._touched=t}destroy(){var e;const t=this.resources;for(const r in t){const s=t[r];(e=s.off)==null||e.call(s,"change",this.onResourceChange,this)}this.resources=null}onResourceChange(t){if(this._dirty=!0,t.destroyed){const e=this.resources;for(const r in e)e[r]===t&&(e[r]=null)}else this._updateKey()}}var St=(i=>(i[i.WEBGL=1]="WEBGL",i[i.WEBGPU=2]="WEBGPU",i[i.BOTH=3]="BOTH",i))(St||{});class qt extends vt{constructor(t){super(),this._uniformBindMap=Object.create(null),this._ownedBindGroups=[];let{gpuProgram:e,glProgram:r,groups:s,resources:n,compatibleRenderers:a,groupMap:o}=t;this.gpuProgram=e,this.glProgram=r,a===void 0&&(a=0,e&&(a|=St.WEBGPU),r&&(a|=St.WEBGL)),this.compatibleRenderers=a;const h={};if(!n&&!s&&(n={}),n&&s)throw new Error("[Shader] Cannot have both resources and groups");if(!e&&s&&!o)throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");if(!e&&s&&o)for(const l in o)for(const c in o[l]){const u=o[l][c];h[u]={group:l,binding:c,name:u}}else if(e&&s&&!o){const l=e.structsAndGroups.groups;o={},l.forEach(c=>{o[c.group]=o[c.group]||{},o[c.group][c.binding]=c.name,h[c.name]=c})}else if(n){if(e){const l=e.structsAndGroups.groups;o={},l.forEach(c=>{o[c.group]=o[c.group]||{},o[c.group][c.binding]=c.name,h[c.name]=c})}else{o={},s={99:new yt},this._ownedBindGroups.push(s[99]);let l=0;for(const c in n)h[c]={group:99,binding:l,name:c},o[99]=o[99]||{},o[99][l]=c,l++}s={};for(const l in n){const c=l;let u=n[l];!u.source&&!u._resourceType&&(u=new mt(u));const f=h[c];f&&(s[f.group]||(s[f.group]=new yt,this._ownedBindGroups.push(s[f.group])),s[f.group].setResource(u,f.binding))}}this.groups=s,this._uniformBindMap=o,this.resources=this._buildResourceAccessor(s,h)}addResource(t,e,r){var s,n;(s=this._uniformBindMap)[e]||(s[e]={}),(n=this._uniformBindMap[e])[r]||(n[r]=t),this.groups[e]||(this.groups[e]=new yt,this._ownedBindGroups.push(this.groups[e]))}_buildResourceAccessor(t,e){const r={};for(const s in e){const n=e[s];Object.defineProperty(r,n.name,{get(){return t[n.group].getResource(n.binding)},set(a){t[n.group].setResource(a,n.binding)}})}return r}destroy(t=!1){var e,r;this.emit("destroy",this),t&&((e=this.gpuProgram)==null||e.destroy(),(r=this.glProgram)==null||r.destroy()),this.gpuProgram=null,this.glProgram=null,this.removeAllListeners(),this._uniformBindMap=null,this._ownedBindGroups.forEach(s=>{s.destroy()}),this._ownedBindGroups=null,this.resources=null,this.groups=null}static from(t){const{gpu:e,gl:r,...s}=t;let n,a;return e&&(n=Xt.from(e)),r&&(a=Rr.from(r)),new qt({gpuProgram:n,glProgram:a,...s})}}const si={normal:0,add:1,multiply:2,screen:3,overlay:4,erase:5,"normal-npm":6,"add-npm":7,"screen-npm":8},ie=0,ne=1,ae=2,oe=3,he=4,ce=5,Te=class Gr{constructor(){this.data=0,this.blendMode="normal",this.polygonOffset=0,this.blend=!0,this.depthMask=!0}get blend(){return!!(this.data&1<<ie)}set blend(t){!!(this.data&1<<ie)!==t&&(this.data^=1<<ie)}get offsets(){return!!(this.data&1<<ne)}set offsets(t){!!(this.data&1<<ne)!==t&&(this.data^=1<<ne)}set cullMode(t){if(t==="none"){this.culling=!1;return}this.culling=!0,this.clockwiseFrontFace=t==="front"}get cullMode(){return this.culling?this.clockwiseFrontFace?"front":"back":"none"}get culling(){return!!(this.data&1<<ae)}set culling(t){!!(this.data&1<<ae)!==t&&(this.data^=1<<ae)}get depthTest(){return!!(this.data&1<<oe)}set depthTest(t){!!(this.data&1<<oe)!==t&&(this.data^=1<<oe)}get depthMask(){return!!(this.data&1<<ce)}set depthMask(t){!!(this.data&1<<ce)!==t&&(this.data^=1<<ce)}get clockwiseFrontFace(){return!!(this.data&1<<he)}set clockwiseFrontFace(t){!!(this.data&1<<he)!==t&&(this.data^=1<<he)}get blendMode(){return this._blendMode}set blendMode(t){this.blend=t!=="none",this._blendMode=t,this._blendModeId=si[t]||0}get polygonOffset(){return this._polygonOffset}set polygonOffset(t){this.offsets=!!t,this._polygonOffset=t}toString(){return`[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`}static for2d(){const t=new Gr;return t.depthTest=!1,t.blend=!0,t}};Te.default2d=Te.for2d();let Ur=Te;class Er{static init(t){Object.defineProperty(this,"resizeTo",{set(e){globalThis.removeEventListener("resize",this.queueResize),this._resizeTo=e,e&&(globalThis.addEventListener("resize",this.queueResize),this.resize())},get(){return this._resizeTo}}),this.queueResize=()=>{this._resizeTo&&(this._cancelResize(),this._resizeId=requestAnimationFrame(()=>this.resize()))},this._cancelResize=()=>{this._resizeId&&(cancelAnimationFrame(this._resizeId),this._resizeId=null)},this.resize=()=>{if(!this._resizeTo)return;this._cancelResize();let e,r;if(this._resizeTo===globalThis.window)e=globalThis.innerWidth,r=globalThis.innerHeight;else{const{clientWidth:s,clientHeight:n}=this._resizeTo;e=s,r=n}this.renderer.resize(e,r),this.render()},this._resizeId=null,this._resizeTo=null,this.resizeTo=t.resizeTo||null}static destroy(){globalThis.removeEventListener("resize",this.queueResize),this._cancelResize(),this._cancelResize=null,this.queueResize=null,this.resizeTo=null,this.resize=null}}Er.extension=R.Application;class Dr{static init(t){t=Object.assign({autoStart:!0,sharedTicker:!1},t),Object.defineProperty(this,"ticker",{set(e){this._ticker&&this._ticker.remove(this.render,this),this._ticker=e,e&&e.add(this.render,this,zs.LOW)},get(){return this._ticker}}),this.stop=()=>{this._ticker.stop()},this.start=()=>{this._ticker.start()},this._ticker=null,this.ticker=t.sharedTicker?Ke.shared:new Ke,t.autoStart&&this.start()}static destroy(){if(this._ticker){const t=this._ticker;this.ticker=null,t.destroy()}}}Dr.extension=R.Application;var ii=ai,le={a:7,c:6,h:1,l:2,m:2,q:4,s:4,t:2,v:1,z:0},ni=/([astvzqmhlc])([^astvzqmhlc]*)/ig;function ai(i){var t=[];return i.replace(ni,function(e,r,s){var n=r.toLowerCase();for(s=hi(s),n=="m"&&s.length>2&&(t.push([r].concat(s.splice(0,2))),n="l",r=r=="m"?"l":"L");;){if(s.length==le[n])return s.unshift(r),t.push(s);if(s.length<le[n])throw new Error("malformed path data");t.push([r].concat(s.splice(0,le[n])))}}),t}var oi=/-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;function hi(i){var t=i.match(oi);return t?t.map(Number):[]}const ci=Gs(ii);function li(i,t){const e=ci(i),r=[];let s=null,n=0,a=0;for(let o=0;o<e.length;o++){const h=e[o],l=h[0],c=h;switch(l){case"M":n=c[1],a=c[2],t.moveTo(n,a);break;case"m":n+=c[1],a+=c[2],t.moveTo(n,a);break;case"H":n=c[1],t.lineTo(n,a);break;case"h":n+=c[1],t.lineTo(n,a);break;case"V":a=c[1],t.lineTo(n,a);break;case"v":a+=c[1],t.lineTo(n,a);break;case"L":n=c[1],a=c[2],t.lineTo(n,a);break;case"l":n+=c[1],a+=c[2],t.lineTo(n,a);break;case"C":n=c[5],a=c[6],t.bezierCurveTo(c[1],c[2],c[3],c[4],n,a);break;case"c":t.bezierCurveTo(n+c[1],a+c[2],n+c[3],a+c[4],n+c[5],a+c[6]),n+=c[5],a+=c[6];break;case"S":n=c[3],a=c[4],t.bezierCurveToShort(c[1],c[2],n,a);break;case"s":t.bezierCurveToShort(n+c[1],a+c[2],n+c[3],a+c[4]),n+=c[3],a+=c[4];break;case"Q":n=c[3],a=c[4],t.quadraticCurveTo(c[1],c[2],n,a);break;case"q":t.quadraticCurveTo(n+c[1],a+c[2],n+c[3],a+c[4]),n+=c[3],a+=c[4];break;case"T":n=c[1],a=c[2],t.quadraticCurveToShort(n,a);break;case"t":n+=c[1],a+=c[2],t.quadraticCurveToShort(n,a);break;case"A":n=c[6],a=c[7],t.arcToSvg(c[1],c[2],c[3],c[4],c[5],n,a);break;case"a":n+=c[6],a+=c[7],t.arcToSvg(c[1],c[2],c[3],c[4],c[5],n,a);break;case"Z":case"z":t.closePath(),r.length>0&&(s=r.pop(),s?(n=s.startX,a=s.startY):(n=0,a=0)),s=null;break;default:ot(`Unknown SVG path command: ${l}`)}l!=="Z"&&l!=="z"&&s===null&&(s={startX:n,startY:a},r.push(s))}return t}class Ae{constructor(t=0,e=0,r=0){this.type="circle",this.x=t,this.y=e,this.radius=r}clone(){return new Ae(this.x,this.y,this.radius)}contains(t,e){if(this.radius<=0)return!1;const r=this.radius*this.radius;let s=this.x-t,n=this.y-e;return s*=s,n*=n,s+n<=r}strokeContains(t,e,r){if(this.radius===0)return!1;const s=this.x-t,n=this.y-e,a=this.radius,o=r/2,h=Math.sqrt(s*s+n*n);return h<a+o&&h>a-o}getBounds(t){return t=t||new Q,t.x=this.x-this.radius,t.y=this.y-this.radius,t.width=this.radius*2,t.height=this.radius*2,t}copyFrom(t){return this.x=t.x,this.y=t.y,this.radius=t.radius,this}copyTo(t){return t.copyFrom(this),t}toString(){return`[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`}}class Fe{constructor(t=0,e=0,r=0,s=0){this.type="ellipse",this.x=t,this.y=e,this.halfWidth=r,this.halfHeight=s}clone(){return new Fe(this.x,this.y,this.halfWidth,this.halfHeight)}contains(t,e){if(this.halfWidth<=0||this.halfHeight<=0)return!1;let r=(t-this.x)/this.halfWidth,s=(e-this.y)/this.halfHeight;return r*=r,s*=s,r+s<=1}strokeContains(t,e,r){const{halfWidth:s,halfHeight:n}=this;if(s<=0||n<=0)return!1;const a=r/2,o=s-a,h=n-a,l=s+a,c=n+a,u=t-this.x,f=e-this.y,p=u*u/(o*o)+f*f/(h*h),d=u*u/(l*l)+f*f/(c*c);return p>1&&d<=1}getBounds(){return new Q(this.x-this.halfWidth,this.y-this.halfHeight,this.halfWidth*2,this.halfHeight*2)}copyFrom(t){return this.x=t.x,this.y=t.y,this.halfWidth=t.halfWidth,this.halfHeight=t.halfHeight,this}copyTo(t){return t.copyFrom(this),t}toString(){return`[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`}}function ui(i,t,e,r,s,n){const a=i-e,o=t-r,h=s-e,l=n-r,c=a*h+o*l,u=h*h+l*l;let f=-1;u!==0&&(f=c/u);let p,d;f<0?(p=e,d=r):f>1?(p=s,d=n):(p=e+f*h,d=r+f*l);const x=i-p,g=t-d;return x*x+g*g}class It{constructor(...t){this.type="polygon";let e=Array.isArray(t[0])?t[0]:t;if(typeof e[0]!="number"){const r=[];for(let s=0,n=e.length;s<n;s++)r.push(e[s].x,e[s].y);e=r}this.points=e,this.closePath=!0}clone(){const t=this.points.slice(),e=new It(t);return e.closePath=this.closePath,e}contains(t,e){let r=!1;const s=this.points.length/2;for(let n=0,a=s-1;n<s;a=n++){const o=this.points[n*2],h=this.points[n*2+1],l=this.points[a*2],c=this.points[a*2+1];h>e!=c>e&&t<(l-o)*((e-h)/(c-h))+o&&(r=!r)}return r}strokeContains(t,e,r){const s=r/2,n=s*s,{points:a}=this,o=a.length-(this.closePath?0:2);for(let h=0;h<o;h+=2){const l=a[h],c=a[h+1],u=a[(h+2)%a.length],f=a[(h+3)%a.length];if(ui(t,e,l,c,u,f)<=n)return!0}return!1}getBounds(t){t=t||new Q;const e=this.points;let r=1/0,s=-1/0,n=1/0,a=-1/0;for(let o=0,h=e.length;o<h;o+=2){const l=e[o],c=e[o+1];r=l<r?l:r,s=l>s?l:s,n=c<n?c:n,a=c>a?c:a}return t.x=r,t.width=s-r,t.y=n,t.height=a-n,t}copyFrom(t){return this.points=t.points.slice(),this.closePath=t.closePath,this}copyTo(t){return t.copyFrom(this),t}toString(){return`[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((t,e)=>`${t}, ${e}`,"")}]`}get lastX(){return this.points[this.points.length-2]}get lastY(){return this.points[this.points.length-1]}get x(){return this.points[this.points.length-2]}get y(){return this.points[this.points.length-1]}}const Lt=(i,t,e,r,s,n)=>{const a=i-e,o=t-r,h=Math.sqrt(a*a+o*o);return h>=s-n&&h<=s+n};class Re{constructor(t=0,e=0,r=0,s=0,n=20){this.type="roundedRectangle",this.x=t,this.y=e,this.width=r,this.height=s,this.radius=n}getBounds(t){return t=t||new Q,t.x=this.x,t.y=this.y,t.width=this.width,t.height=this.height,t}clone(){return new Re(this.x,this.y,this.width,this.height,this.radius)}copyFrom(t){return this.x=t.x,this.y=t.y,this.width=t.width,this.height=t.height,this}copyTo(t){return t.copyFrom(this),t}contains(t,e){if(this.width<=0||this.height<=0)return!1;if(t>=this.x&&t<=this.x+this.width&&e>=this.y&&e<=this.y+this.height){const r=Math.max(0,Math.min(this.radius,Math.min(this.width,this.height)/2));if(e>=this.y+r&&e<=this.y+this.height-r||t>=this.x+r&&t<=this.x+this.width-r)return!0;let s=t-(this.x+r),n=e-(this.y+r);const a=r*r;if(s*s+n*n<=a||(s=t-(this.x+this.width-r),s*s+n*n<=a)||(n=e-(this.y+this.height-r),s*s+n*n<=a)||(s=t-(this.x+r),s*s+n*n<=a))return!0}return!1}strokeContains(t,e,r){const{x:s,y:n,width:a,height:o,radius:h}=this,l=r/2,c=s+h,u=n+h,f=a-h*2,p=o-h*2,d=s+a,x=n+o;return(t>=s-l&&t<=s+l||t>=d-l&&t<=d+l)&&e>=u&&e<=u+p||(e>=n-l&&e<=n+l||e>=x-l&&e<=x+l)&&t>=c&&t<=c+f?!0:t<c&&e<u&&Lt(t,e,c,u,h,l)||t>d-h&&e<u&&Lt(t,e,d-h,u,h,l)||t>d-h&&e>x-h&&Lt(t,e,d-h,x-h,h,l)||t<c&&e>x-h&&Lt(t,e,c,x-h,h,l)}toString(){return`[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`}}var L=(i=>(i[i.MAP_READ=1]="MAP_READ",i[i.MAP_WRITE=2]="MAP_WRITE",i[i.COPY_SRC=4]="COPY_SRC",i[i.COPY_DST=8]="COPY_DST",i[i.INDEX=16]="INDEX",i[i.VERTEX=32]="VERTEX",i[i.UNIFORM=64]="UNIFORM",i[i.STORAGE=128]="STORAGE",i[i.INDIRECT=256]="INDIRECT",i[i.QUERY_RESOLVE=512]="QUERY_RESOLVE",i[i.STATIC=1024]="STATIC",i))(L||{});class at extends vt{constructor(t){let{data:e,size:r}=t;const{usage:s,label:n,shrinkToFit:a}=t;super(),this.uid=K("buffer"),this._resourceType="buffer",this._resourceId=K("resource"),this._touched=0,this._updateID=1,this.shrinkToFit=!0,this.destroyed=!1,e instanceof Array&&(e=new Float32Array(e)),this._data=e,r=r??(e==null?void 0:e.byteLength);const o=!!e;this.descriptor={size:r,usage:s,mappedAtCreation:o,label:n},this.shrinkToFit=a??!0}get data(){return this._data}set data(t){this.setDataWithSize(t,t.length,!0)}get static(){return!!(this.descriptor.usage&L.STATIC)}set static(t){t?this.descriptor.usage|=L.STATIC:this.descriptor.usage&=~L.STATIC}setDataWithSize(t,e,r){if(this._updateID++,this._updateSize=e*t.BYTES_PER_ELEMENT,this._data===t){r&&this.emit("update",this);return}const s=this._data;if(this._data=t,s.length!==t.length){!this.shrinkToFit&&t.byteLength<s.byteLength?r&&this.emit("update",this):(this.descriptor.size=t.byteLength,this._resourceId=K("resource"),this.emit("change",this));return}r&&this.emit("update",this)}update(t){this._updateSize=t??this._updateSize,this._updateID++,this.emit("update",this)}destroy(){this.destroyed=!0,this.emit("destroy",this),this.emit("change",this),this._data=null,this.descriptor=null,this.removeAllListeners()}}function Wr(i,t){if(!(i instanceof at)){let e=t?L.INDEX:L.VERTEX;i instanceof Array&&(t?(i=new Uint32Array(i),e=L.INDEX|L.COPY_DST):(i=new Float32Array(i),e=L.VERTEX|L.COPY_DST)),i=new at({data:i,label:t?"index-mesh-buffer":"vertex-mesh-buffer",usage:e})}return i}function di(i,t,e){const r=i.getAttribute(t);if(!r)return e.minX=0,e.minY=0,e.maxX=0,e.maxY=0,e;const s=r.buffer.data;let n=1/0,a=1/0,o=-1/0,h=-1/0;const l=s.BYTES_PER_ELEMENT,c=(r.offset||0)/l,u=(r.stride||2*4)/l;for(let f=c;f<s.length;f+=u){const p=s[f],d=s[f+1];p>o&&(o=p),d>h&&(h=d),p<n&&(n=p),d<a&&(a=d)}return e.minX=n,e.minY=a,e.maxX=o,e.maxY=h,e}function fi(i){return(i instanceof at||Array.isArray(i)||i.BYTES_PER_ELEMENT)&&(i={buffer:i}),i.buffer=Wr(i.buffer,!1),i}class Ie extends vt{constructor(t){const{attributes:e,indexBuffer:r,topology:s}=t;super(),this.uid=K("geometry"),this._layoutKey=0,this.instanceCount=1,this._bounds=new Gt,this._boundsDirty=!0,this.attributes=e,this.buffers=[],this.instanceCount=t.instanceCount||1;for(const n in e){const a=e[n]=fi(e[n]);this.buffers.indexOf(a.buffer)===-1&&(this.buffers.push(a.buffer),a.buffer.on("update",this.onBufferUpdate,this),a.buffer.on("change",this.onBufferUpdate,this))}r&&(this.indexBuffer=Wr(r,!0),this.buffers.push(this.indexBuffer)),this.topology=s||"triangle-list"}onBufferUpdate(){this._boundsDirty=!0,this.emit("update",this)}getAttribute(t){return this.attributes[t]}getIndex(){return this.indexBuffer}getBuffer(t){return this.getAttribute(t).buffer}getSize(){for(const t in this.attributes){const e=this.attributes[t];return e.buffer.data.length/(e.stride/4||e.size)}return 0}get bounds(){return this._boundsDirty?(this._boundsDirty=!1,di(this,"aPosition",this._bounds)):this._bounds}destroy(t=!1){this.emit("destroy",this),this.removeAllListeners(),t&&this.buffers.forEach(e=>e.destroy()),this.attributes=null,this.buffers=null,this.indexBuffer=null,this._bounds=null}}const pi=new Float32Array(1),gi=new Uint32Array(1);class mi extends Ie{constructor(){const e=new at({data:pi,label:"attribute-batch-buffer",usage:L.VERTEX|L.COPY_DST,shrinkToFit:!1}),r=new at({data:gi,label:"index-batch-buffer",usage:L.INDEX|L.COPY_DST,shrinkToFit:!1}),s=6*4;super({attributes:{aPosition:{buffer:e,format:"float32x2",stride:s,offset:0,location:1},aUV:{buffer:e,format:"float32x2",stride:s,offset:2*4,location:3},aColor:{buffer:e,format:"unorm8x4",stride:s,offset:4*4,location:0},aTextureIdAndRound:{buffer:e,format:"uint16x2",stride:s,offset:5*4,location:2}},indexBuffer:r})}}function xi(){const i=Ar();return i.getParameter(i.MAX_TEXTURE_IMAGE_UNITS)}const et=xi(),Lr={};function _i(i,t){let e=0;for(let r=0;r<t;r++)e=e*31+i[r].uid>>>0;return Lr[e]||yi(i,e)}function yi(i,t){const e={};let r=0;for(let n=0;n<et;n++){const a=n<i.length?i[n]:O.EMPTY.source;e[r++]=a.source,e[r++]=a.style}const s=new yt(e);return Lr[t]=s,s}class Je{constructor(t){typeof t=="number"?this.rawBinaryData=new ArrayBuffer(t):t instanceof Uint8Array?this.rawBinaryData=t.buffer:this.rawBinaryData=t,this.uint32View=new Uint32Array(this.rawBinaryData),this.float32View=new Float32Array(this.rawBinaryData),this.size=this.rawBinaryData.byteLength}get int8View(){return this._int8View||(this._int8View=new Int8Array(this.rawBinaryData)),this._int8View}get uint8View(){return this._uint8View||(this._uint8View=new Uint8Array(this.rawBinaryData)),this._uint8View}get int16View(){return this._int16View||(this._int16View=new Int16Array(this.rawBinaryData)),this._int16View}get int32View(){return this._int32View||(this._int32View=new Int32Array(this.rawBinaryData)),this._int32View}get float64View(){return this._float64Array||(this._float64Array=new Float64Array(this.rawBinaryData)),this._float64Array}get bigUint64View(){return this._bigUint64Array||(this._bigUint64Array=new BigUint64Array(this.rawBinaryData)),this._bigUint64Array}view(t){return this[`${t}View`]}destroy(){this.rawBinaryData=null,this._int8View=null,this._uint8View=null,this._int16View=null,this.uint16View=null,this._int32View=null,this.uint32View=null,this.float32View=null}static sizeOf(t){switch(t){case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;default:throw new Error(`${t} isn't a valid view type`)}}}function tr(i,t){const e=i.byteLength/8|0,r=new Float64Array(i,0,e);new Float64Array(t,0,e).set(r);const n=i.byteLength-e*8;if(n>0){const a=new Uint8Array(i,e*8,n);new Uint8Array(t,e*8,n).set(a)}}const bi={normal:"normal-npm",add:"add-npm",screen:"screen-npm"};function er(i,t){return t.alphaMode==="no-premultiply-alpha"&&bi[i]||i}class rr{constructor(){this.ids=Object.create(null),this.textures=[],this.count=0}clear(){for(let t=0;t<this.count;t++){const e=this.textures[t];this.textures[t]=null,this.ids[e.uid]=null}this.count=0}}class sr{constructor(){this.renderPipeId="batch",this.action="startBatch",this.start=0,this.size=0,this.blendMode="normal",this.canBundle=!0}destroy(){this.textures=null,this.gpuBindGroup=null,this.bindGroup=null,this.batcher=null}}let At=0;const Hr=class Or{constructor(t={}){this.uid=K("batcher"),this.dirty=!0,this.batchIndex=0,this.batches=[],this._vertexSize=6,this._elements=[],this._batchPool=[],this._batchPoolIndex=0,this._textureBatchPool=[],this._textureBatchPoolIndex=0,t={...Or.defaultOptions,...t};const{vertexSize:e,indexSize:r}=t;this.attributeBuffer=new Je(e*this._vertexSize*4),this.indexBuffer=new Uint16Array(r)}begin(){this.batchIndex=0,this.elementSize=0,this.elementStart=0,this.indexSize=0,this.attributeSize=0,this._batchPoolIndex=0,this._textureBatchPoolIndex=0,this._batchIndexStart=0,this._batchIndexSize=0,this.dirty=!0}add(t){this._elements[this.elementSize++]=t,t.indexStart=this.indexSize,t.location=this.attributeSize,t.batcher=this,this.indexSize+=t.indexSize,this.attributeSize+=t.vertexSize*this._vertexSize}checkAndUpdateTexture(t,e){const r=t.batch.textures.ids[e._source.uid];return!r&&r!==0?!1:(t.textureId=r,t.texture=e,!0)}updateElement(t){this.dirty=!0,t.packAttributes(this.attributeBuffer.float32View,this.attributeBuffer.uint32View,t.location,t.textureId)}break(t){const e=this._elements;let r=this._textureBatchPool[this._textureBatchPoolIndex++]||new rr;if(r.clear(),!e[this.elementStart])return;const s=e[this.elementStart];let n=er(s.blendMode,s.texture._source);this.attributeSize*4>this.attributeBuffer.size&&this._resizeAttributeBuffer(this.attributeSize*4),this.indexSize>this.indexBuffer.length&&this._resizeIndexBuffer(this.indexSize);const a=this.attributeBuffer.float32View,o=this.attributeBuffer.uint32View,h=this.indexBuffer;let l=this._batchIndexSize,c=this._batchIndexStart,u="startBatch",f=this._batchPool[this._batchPoolIndex++]||new sr;for(let p=this.elementStart;p<this.elementSize;++p){const d=e[p];e[p]=null;const g=d.texture._source,_=er(d.blendMode,g),m=n!==_;if(g._batchTick===At&&!m){d.textureId=g._textureBindLocation,l+=d.indexSize,d.packAttributes(a,o,d.location,d.textureId),d.packIndex(h,d.indexStart,d.location/this._vertexSize),d.batch=f;continue}g._batchTick=At,(r.count>=et||m)&&(this._finishBatch(f,c,l-c,r,n,t,u),u="renderBatch",c=l,n=_,r=this._textureBatchPool[this._textureBatchPoolIndex++]||new rr,r.clear(),f=this._batchPool[this._batchPoolIndex++]||new sr,++At),d.textureId=g._textureBindLocation=r.count,r.ids[g.uid]=r.count,r.textures[r.count++]=g,d.batch=f,l+=d.indexSize,d.packAttributes(a,o,d.location,d.textureId),d.packIndex(h,d.indexStart,d.location/this._vertexSize)}r.count>0&&(this._finishBatch(f,c,l-c,r,n,t,u),c=l,++At),this.elementStart=this.elementSize,this._batchIndexStart=c,this._batchIndexSize=l}_finishBatch(t,e,r,s,n,a,o){t.gpuBindGroup=null,t.action=o,t.batcher=this,t.textures=s,t.blendMode=n,t.start=e,t.size=r,++At,a.add(t)}finish(t){this.break(t)}ensureAttributeBuffer(t){t*4<=this.attributeBuffer.size||this._resizeAttributeBuffer(t*4)}ensureIndexBuffer(t){t<=this.indexBuffer.length||this._resizeIndexBuffer(t)}_resizeAttributeBuffer(t){const e=Math.max(t,this.attributeBuffer.size*2),r=new Je(e);tr(this.attributeBuffer.rawBinaryData,r.rawBinaryData),this.attributeBuffer=r}_resizeIndexBuffer(t){const e=this.indexBuffer;let r=Math.max(t,e.length*1.5);r+=r%2;const s=r>65535?new Uint32Array(r):new Uint16Array(r);if(s.BYTES_PER_ELEMENT!==e.BYTES_PER_ELEMENT)for(let n=0;n<e.length;n++)s[n]=e[n];else tr(e.buffer,s.buffer);this.indexBuffer=s}destroy(){for(let t=0;t<this.batches.length;t++)this.batches[t].destroy();this.batches=null;for(let t=0;t<this._elements.length;t++)this._elements[t].batch=null;this._elements=null,this.indexBuffer=null,this.attributeBuffer.destroy(),this.attributeBuffer=null}};Hr.defaultOptions={vertexSize:4,indexSize:6};let Si=Hr;function wi(i,t,e,r,s,n,a,o=null){let h=0;e*=t,s*=n;const l=o.a,c=o.b,u=o.c,f=o.d,p=o.tx,d=o.ty;for(;h<a;){const x=i[e],g=i[e+1];r[s]=l*x+u*g+p,r[s+1]=c*x+f*g+d,s+=n,e+=t,h++}}function Ti(i,t,e,r){let s=0;for(t*=e;s<r;)i[t]=0,i[t+1]=0,t+=e,s++}function $r(i,t,e,r,s){const n=t.a,a=t.b,o=t.c,h=t.d,l=t.tx,c=t.ty;e=e||0,r=r||2,s=s||i.length/r-e;let u=e*r;for(let f=0;f<s;f++){const p=i[u],d=i[u+1];i[u]=n*p+o*d+l,i[u+1]=a*p+h*d+c,u+=r}}function vi(i,t){if(i===16777215||!t)return t;if(t===16777215||!i)return i;const e=i>>16&255,r=i>>8&255,s=i&255,n=t>>16&255,a=t>>8&255,o=t&255,h=e*n/255,l=r*a/255,c=s*o/255;return(h<<16)+(l<<8)+c}class ze{constructor(){this.batcher=null,this.batch=null,this.applyTransform=!0,this.roundPixels=0}get blendMode(){return this.applyTransform?this.renderable.groupBlendMode:"normal"}packIndex(t,e,r){const s=this.geometryData.indices;for(let n=0;n<this.indexSize;n++)t[e++]=s[n+this.indexOffset]+r-this.vertexOffset}packAttributes(t,e,r,s){const n=this.geometryData,a=this.renderable,o=n.vertices,h=n.uvs,l=this.vertexOffset*2,c=(this.vertexOffset+this.vertexSize)*2,u=this.color,f=u>>16|u&65280|(u&255)<<16;if(this.applyTransform){const p=vi(f,a.groupColor)+(this.alpha*a.groupAlpha*255<<24),d=a.groupTransform,x=s<<16|this.roundPixels&65535,g=d.a,_=d.b,m=d.c,y=d.d,b=d.tx,P=d.ty;for(let k=l;k<c;k+=2){const T=o[k],v=o[k+1];t[r]=g*T+m*v+b,t[r+1]=_*T+y*v+P,t[r+2]=h[k],t[r+3]=h[k+1],e[r+4]=p,e[r+5]=x,r+=6}}else{const p=f+(this.alpha*255<<24);for(let d=l;d<c;d+=2)t[r]=o[d],t[r+1]=o[d+1],t[r+2]=h[d],t[r+3]=h[d+1],e[r+4]=p,e[r+5]=s<<16,r+=6}}get vertSize(){return this.vertexSize}copyTo(t){t.indexOffset=this.indexOffset,t.indexSize=this.indexSize,t.vertexOffset=this.vertexOffset,t.vertexSize=this.vertexSize,t.color=this.color,t.alpha=this.alpha,t.texture=this.texture,t.geometryData=this.geometryData}reset(){this.applyTransform=!0}}const ue={build(i,t){let e,r,s,n,a,o;if(i.type==="circle"){const b=i;e=b.x,r=b.y,a=o=b.radius,s=n=0}else if(i.type==="ellipse"){const b=i;e=b.x,r=b.y,a=b.halfWidth,o=b.halfHeight,s=n=0}else{const b=i,P=b.width/2,k=b.height/2;e=b.x+P,r=b.y+k,a=o=Math.max(0,Math.min(b.radius,Math.min(P,k))),s=P-a,n=k-o}if(!(a>=0&&o>=0&&s>=0&&n>=0))return t;const h=Math.ceil(2.3*Math.sqrt(a+o)),l=h*8+(s?4:0)+(n?4:0);if(l===0)return t;if(h===0)return t[0]=t[6]=e+s,t[1]=t[3]=r+n,t[2]=t[4]=e-s,t[5]=t[7]=r-n,t;let c=0,u=h*4+(s?2:0)+2,f=u,p=l,d=s+a,x=n,g=e+d,_=e-d,m=r+x;if(t[c++]=g,t[c++]=m,t[--u]=m,t[--u]=_,n){const b=r-x;t[f++]=_,t[f++]=b,t[--p]=b,t[--p]=g}for(let b=1;b<h;b++){const P=Math.PI/2*(b/h),k=s+Math.cos(P)*a,T=n+Math.sin(P)*o,v=e+k,S=e-k,w=r+T,G=r-T;t[c++]=v,t[c++]=w,t[--u]=w,t[--u]=S,t[f++]=S,t[f++]=G,t[--p]=G,t[--p]=v}d=s,x=n+o,g=e+d,_=e-d,m=r+x;const y=r-x;return t[c++]=g,t[c++]=m,t[--p]=y,t[--p]=g,s&&(t[c++]=_,t[c++]=m,t[--p]=y,t[--p]=_),t},triangulate(i,t,e,r,s,n){if(i.length===0)return;let a=0,o=0;for(let c=0;c<i.length;c+=2)a+=i[c],o+=i[c+1];a/=i.length/2,o/=i.length/2;let h=r;t[h*e]=a,t[h*e+1]=o;const l=h++;for(let c=0;c<i.length;c+=2)t[h*e]=i[c],t[h*e+1]=i[c+1],c>0&&(s[n++]=h,s[n++]=l,s[n++]=h-1),h++;s[n++]=l+1,s[n++]=l,s[n++]=h-1}},Pi=1e-4,ir=1e-4;function Ci(i){const t=i.length;if(t<6)return 1;let e=0;for(let r=0,s=i[t-2],n=i[t-1];r<t;r+=2){const a=i[r],o=i[r+1];e+=(a-s)*(o+n),s=a,n=o}return e<0?-1:1}function nr(i,t,e,r,s,n,a,o){const h=i-e*s,l=t-r*s,c=i+e*n,u=t+r*n;let f,p;a?(f=r,p=-e):(f=-r,p=e);const d=h+f,x=l+p,g=c+f,_=u+p;return o.push(d,x),o.push(g,_),2}function dt(i,t,e,r,s,n,a,o){const h=e-i,l=r-t;let c=Math.atan2(h,l),u=Math.atan2(s-i,n-t);o&&c<u?c+=Math.PI*2:!o&&c>u&&(u+=Math.PI*2);let f=c;const p=u-c,d=Math.abs(p),x=Math.sqrt(h*h+l*l),g=(15*d*Math.sqrt(x)/Math.PI>>0)+1,_=p/g;if(f+=_,o){a.push(i,t),a.push(e,r);for(let m=1,y=f;m<g;m++,y+=_)a.push(i,t),a.push(i+Math.sin(y)*x,t+Math.cos(y)*x);a.push(i,t),a.push(s,n)}else{a.push(e,r),a.push(i,t);for(let m=1,y=f;m<g;m++,y+=_)a.push(i+Math.sin(y)*x,t+Math.cos(y)*x),a.push(i,t);a.push(s,n),a.push(i,t)}return g*2}function Mi(i,t,e,r,s,n,a,o,h){const l=Pi;if(i.length===0)return;const c=t;let u=c.alignment;if(t.alignment!==.5){let z=Ci(i);u=(u-.5)*z+.5}const f=new gt(i[0],i[1]),p=new gt(i[i.length-2],i[i.length-1]),d=r,x=Math.abs(f.x-p.x)<l&&Math.abs(f.y-p.y)<l;if(d){i=i.slice(),x&&(i.pop(),i.pop(),p.set(i[i.length-2],i[i.length-1]));const z=(f.x+p.x)*.5,st=(p.y+f.y)*.5;i.unshift(z,st),i.push(z,st)}const g=s,_=i.length/2;let m=i.length;const y=g.length/2,b=c.width/2,P=b*b,k=c.miterLimit*c.miterLimit;let T=i[0],v=i[1],S=i[2],w=i[3],G=0,Y=0,B=-(v-w),C=T-S,I=0,U=0,j=Math.sqrt(B*B+C*C);B/=j,C/=j,B*=b,C*=b;const Pt=u,A=(1-Pt)*2,F=Pt*2;d||(c.cap==="round"?m+=dt(T-B*(A-F)*.5,v-C*(A-F)*.5,T-B*A,v-C*A,T+B*F,v+C*F,g,!0)+2:c.cap==="square"&&(m+=nr(T,v,B,C,A,F,!0,g))),g.push(T-B*A,v-C*A),g.push(T+B*F,v+C*F);for(let z=1;z<_-1;++z){T=i[(z-1)*2],v=i[(z-1)*2+1],S=i[z*2],w=i[z*2+1],G=i[(z+1)*2],Y=i[(z+1)*2+1],B=-(v-w),C=T-S,j=Math.sqrt(B*B+C*C),B/=j,C/=j,B*=b,C*=b,I=-(w-Y),U=S-G,j=Math.sqrt(I*I+U*U),I/=j,U/=j,I*=b,U*=b;const st=S-T,Ct=v-w,Mt=S-G,kt=Y-w,je=st*Mt+Ct*kt,Ut=Ct*Mt-kt*st,Bt=Ut<0;if(Math.abs(Ut)<.001*Math.abs(je)){g.push(S-B*A,w-C*A),g.push(S+B*F,w+C*F),je>=0&&(c.join==="round"?m+=dt(S,w,S-B*A,w-C*A,S-I*A,w-U*A,g,!1)+4:m+=2,g.push(S-I*F,w-U*F),g.push(S+I*A,w+U*A));continue}const Ye=(-B+T)*(-C+w)-(-B+S)*(-C+v),Xe=(-I+G)*(-U+w)-(-I+S)*(-U+Y),Et=(st*Xe-Mt*Ye)/Ut,Dt=(kt*Ye-Ct*Xe)/Ut,Kt=(Et-S)*(Et-S)+(Dt-w)*(Dt-w),ht=S+(Et-S)*A,ct=w+(Dt-w)*A,lt=S-(Et-S)*F,ut=w-(Dt-w)*F,Rs=Math.min(st*st+Ct*Ct,Mt*Mt+kt*kt),qe=Bt?A:F,Is=Rs+qe*qe*P;Kt<=Is?c.join==="bevel"||Kt/P>k?(Bt?(g.push(ht,ct),g.push(S+B*F,w+C*F),g.push(ht,ct),g.push(S+I*F,w+U*F)):(g.push(S-B*A,w-C*A),g.push(lt,ut),g.push(S-I*A,w-U*A),g.push(lt,ut)),m+=2):c.join==="round"?Bt?(g.push(ht,ct),g.push(S+B*F,w+C*F),m+=dt(S,w,S+B*F,w+C*F,S+I*F,w+U*F,g,!0)+4,g.push(ht,ct),g.push(S+I*F,w+U*F)):(g.push(S-B*A,w-C*A),g.push(lt,ut),m+=dt(S,w,S-B*A,w-C*A,S-I*A,w-U*A,g,!1)+4,g.push(S-I*A,w-U*A),g.push(lt,ut)):(g.push(ht,ct),g.push(lt,ut)):(g.push(S-B*A,w-C*A),g.push(S+B*F,w+C*F),c.join==="round"?Bt?m+=dt(S,w,S+B*F,w+C*F,S+I*F,w+U*F,g,!0)+2:m+=dt(S,w,S-B*A,w-C*A,S-I*A,w-U*A,g,!1)+2:c.join==="miter"&&Kt/P<=k&&(Bt?(g.push(lt,ut),g.push(lt,ut)):(g.push(ht,ct),g.push(ht,ct)),m+=2),g.push(S-I*A,w-U*A),g.push(S+I*F,w+U*F),m+=2)}T=i[(_-2)*2],v=i[(_-2)*2+1],S=i[(_-1)*2],w=i[(_-1)*2+1],B=-(v-w),C=T-S,j=Math.sqrt(B*B+C*C),B/=j,C/=j,B*=b,C*=b,g.push(S-B*A,w-C*A),g.push(S+B*F,w+C*F),d||(c.cap==="round"?m+=dt(S-B*(A-F)*.5,w-C*(A-F)*.5,S-B*A,w-C*A,S+B*F,w+C*F,g,!1)+2:c.cap==="square"&&(m+=nr(S,w,B,C,A,F,!1,g)));const Fs=ir*ir;for(let z=y;z<m+y-2;++z)T=g[z*2],v=g[z*2+1],S=g[(z+1)*2],w=g[(z+1)*2+1],G=g[(z+2)*2],Y=g[(z+2)*2+1],!(Math.abs(T*(w-Y)+S*(Y-v)+G*(v-w))<Fs)&&o.push(z,z+1,z+2)}function Vr(i,t,e,r,s,n,a){const o=Us(i,t,2);if(!o)return;for(let l=0;l<o.length;l+=3)n[a++]=o[l]+s,n[a++]=o[l+1]+s,n[a++]=o[l+2]+s;let h=s*r;for(let l=0;l<i.length;l+=2)e[h]=i[l],e[h+1]=i[l+1],h+=r}const ki=[],Bi={build(i,t){for(let e=0;e<i.points.length;e++)t[e]=i.points[e];return t},triangulate(i,t,e,r,s,n){Vr(i,ki,t,e,r,s,n)}},Ai={build(i,t){const e=i,r=e.x,s=e.y,n=e.width,a=e.height;return n>=0&&a>=0&&(t[0]=r,t[1]=s,t[2]=r+n,t[3]=s,t[4]=r+n,t[5]=s+a,t[6]=r,t[7]=s+a),t},triangulate(i,t,e,r,s,n){let a=0;r*=e,t[r+a]=i[0],t[r+a+1]=i[1],a+=e,t[r+a]=i[2],t[r+a+1]=i[3],a+=e,t[r+a]=i[6],t[r+a+1]=i[7],a+=e,t[r+a]=i[4],t[r+a+1]=i[5],a+=e;const o=r/e;s[n++]=o,s[n++]=o+1,s[n++]=o+2,s[n++]=o+1,s[n++]=o+3,s[n++]=o+2}},Fi={build(i,t){return t[0]=i.x,t[1]=i.y,t[2]=i.x2,t[3]=i.y2,t[4]=i.x3,t[5]=i.y3,t},triangulate(i,t,e,r,s,n){let a=0;r*=e,t[r+a]=i[0],t[r+a+1]=i[1],a+=e,t[r+a]=i[2],t[r+a+1]=i[3],a+=e,t[r+a]=i[4],t[r+a+1]=i[5];const o=r/e;s[n++]=o,s[n++]=o+1,s[n++]=o+2}},Ge={rectangle:Ai,polygon:Bi,triangle:Fi,circle:ue,ellipse:ue,roundedRectangle:ue},Ri=new Q;function Ii(i,t){const{geometryData:e,batches:r}=t;r.length=0,e.indices.length=0,e.vertices.length=0,e.uvs.length=0;for(let s=0;s<i.instructions.length;s++){const n=i.instructions[s];if(n.action==="texture")zi(n.data,r,e);else if(n.action==="fill"||n.action==="stroke"){const a=n.action==="stroke",o=n.data.path.shapePath,h=n.data.style,l=n.data.hole;a&&l&&ar(l.shapePath,h,null,!0,r,e),ar(o,h,l,a,r,e)}}}function zi(i,t,e){const{vertices:r,uvs:s,indices:n}=e,a=n.length,o=r.length/2,h=[],l=Ge.rectangle,c=Ri,u=i.image;c.x=i.dx,c.y=i.dy,c.width=i.dw,c.height=i.dh;const f=i.transform;l.build(c,h),f&&$r(h,f),l.triangulate(h,r,2,o,n,a);const p=u.uvs;s.push(p.x0,p.y0,p.x1,p.y1,p.x3,p.y3,p.x2,p.y2);const d=W.get(ze);d.indexOffset=a,d.indexSize=n.length-a,d.vertexOffset=o,d.vertexSize=r.length/2-o,d.color=i.style,d.alpha=i.alpha,d.texture=u,d.geometryData=e,t.push(d)}function ar(i,t,e,r,s,n){const{vertices:a,uvs:o,indices:h}=n,l=i.shapePrimitives.length-1;i.shapePrimitives.forEach(({shape:c,transform:u},f)=>{const p=h.length,d=a.length/2,x=[],g=Ge[c.type];if(g.build(c,x),u&&$r(x,u),r){const b=c.closePath??!0;Mi(x,t,!1,b,a,2,d,h)}else if(e&&l===f){l!==0&&console.warn("[Pixi Graphics] only the last shape have be cut out");const b=[],P=x.slice();Gi(e.shapePath).forEach(T=>{b.push(P.length/2),P.push(...T)}),Vr(P,b,a,2,d,h,p)}else g.triangulate(x,a,2,d,h,p);const _=o.length/2,m=t.texture;if(m!==O.WHITE){const b=t.matrix;u&&b.append(u.clone().invert()),wi(a,2,d,o,_,2,a.length/2-d,b)}else Ti(o,_,2,a.length/2-d);const y=W.get(ze);y.indexOffset=p,y.indexSize=h.length-p,y.vertexOffset=d,y.vertexSize=a.length/2-d,y.color=t.color,y.alpha=t.alpha,y.texture=m,y.geometryData=n,s.push(y)})}function Gi(i){if(!i)return[];const t=i.shapePrimitives,e=[];for(let r=0;r<t.length;r++){const s=t[r].shape,n=[];Ge[s.type].build(s,n),e.push(n)}return e}class Ui{constructor(){this.batches=[],this.geometryData={vertices:[],uvs:[],indices:[]}}}class Ei{constructor(){this.geometry=new mi,this.instructions=new Es}init(){this.instructions.reset()}}const Ue=class ve{constructor(){this._activeBatchers=[],this._gpuContextHash={},this._graphicsDataContextHash=Object.create(null),this._needsContextNeedsRebuild=[]}init(t){ve.defaultOptions.bezierSmoothness=(t==null?void 0:t.bezierSmoothness)??ve.defaultOptions.bezierSmoothness}prerender(){this._returnActiveBatchers()}getContextRenderData(t){return this._graphicsDataContextHash[t.uid]||this._initContextRenderData(t)}updateGpuContext(t){let e=this._gpuContextHash[t.uid]||this._initContext(t);if(t.dirty){e?this._cleanGraphicsContextData(t):e=this._initContext(t),Ii(t,e);const r=t.batchMode;t.customShader||r==="no-batch"?e.isBatchable=!1:r==="auto"&&(e.isBatchable=e.geometryData.vertices.length<400),t.dirty=!1}return e}getGpuContext(t){return this._gpuContextHash[t.uid]||this._initContext(t)}_returnActiveBatchers(){for(let t=0;t<this._activeBatchers.length;t++)W.return(this._activeBatchers[t]);this._activeBatchers.length=0}_initContextRenderData(t){const e=W.get(Ei),{batches:r,geometryData:s}=this._gpuContextHash[t.uid],n=s.vertices.length,a=s.indices.length;for(let c=0;c<r.length;c++)r[c].applyTransform=!1;const o=W.get(Si);this._activeBatchers.push(o),o.ensureAttributeBuffer(n),o.ensureIndexBuffer(a),o.begin();for(let c=0;c<r.length;c++){const u=r[c];o.add(u)}o.finish(e.instructions);const h=e.geometry;h.indexBuffer.setDataWithSize(o.indexBuffer,o.indexSize,!0),h.buffers[0].setDataWithSize(o.attributeBuffer.float32View,o.attributeSize,!0);const l=o.batches;for(let c=0;c<l.length;c++){const u=l[c];u.bindGroup=_i(u.textures.textures,u.textures.count)}return this._graphicsDataContextHash[t.uid]=e,e}_initContext(t){const e=new Ui;return this._gpuContextHash[t.uid]=e,t.on("update",this.onGraphicsContextUpdate,this),t.on("destroy",this.onGraphicsContextDestroy,this),this._gpuContextHash[t.uid]}onGraphicsContextUpdate(t){this._needsContextNeedsRebuild.push(t)}onGraphicsContextDestroy(t){this._cleanGraphicsContextData(t),t.off("update",this.onGraphicsContextUpdate,this),t.off("destroy",this.onGraphicsContextDestroy,this),this._gpuContextHash[t.uid]=null}_cleanGraphicsContextData(t){const e=this._gpuContextHash[t.uid];e.isBatchable||this._graphicsDataContextHash[t.uid]&&(W.return(this.getContextRenderData(t)),this._graphicsDataContextHash[t.uid]=null),e.batches&&e.batches.forEach(r=>{W.return(r)})}destroy(){for(const t of this._needsContextNeedsRebuild)this._gpuContextHash[t.uid]&&this.onGraphicsContextDestroy(t);this._needsContextNeedsRebuild.length=0}};Ue.extension={type:[R.WebGLSystem,R.WebGPUSystem,R.CanvasSystem],name:"graphicsContext"};Ue.defaultOptions={bezierSmoothness:.5};let Ee=Ue;const Di=8,Ht=11920929e-14,Wi=1;function Nr(i,t,e,r,s,n,a,o,h,l){const u=Math.min(.99,Math.max(0,l??Ee.defaultOptions.bezierSmoothness));let f=(Wi-u)/1;return f*=f,Li(t,e,r,s,n,a,o,h,i,f),i}function Li(i,t,e,r,s,n,a,o,h,l){Pe(i,t,e,r,s,n,a,o,h,l,0),h.push(a,o)}function Pe(i,t,e,r,s,n,a,o,h,l,c){if(c>Di)return;const u=(i+e)/2,f=(t+r)/2,p=(e+s)/2,d=(r+n)/2,x=(s+a)/2,g=(n+o)/2,_=(u+p)/2,m=(f+d)/2,y=(p+x)/2,b=(d+g)/2,P=(_+y)/2,k=(m+b)/2;if(c>0){let T=a-i,v=o-t;const S=Math.abs((e-a)*v-(r-o)*T),w=Math.abs((s-a)*v-(n-o)*T);if(S>Ht&&w>Ht){if((S+w)*(S+w)<=l*(T*T+v*v)){h.push(P,k);return}}else if(S>Ht){if(S*S<=l*(T*T+v*v)){h.push(P,k);return}}else if(w>Ht){if(w*w<=l*(T*T+v*v)){h.push(P,k);return}}else if(T=P-(i+a)/2,v=k-(t+o)/2,T*T+v*v<=l){h.push(P,k);return}}Pe(i,t,u,f,_,m,P,k,h,l,c+1),Pe(P,k,y,b,x,g,a,o,h,l,c+1)}const Hi=8,Oi=11920929e-14,$i=1;function Vi(i,t,e,r,s,n,a,o){const l=Math.min(.99,Math.max(0,o??Ee.defaultOptions.bezierSmoothness));let c=($i-l)/1;return c*=c,Ni(t,e,r,s,n,a,i,c),i}function Ni(i,t,e,r,s,n,a,o){Ce(a,i,t,e,r,s,n,o,0),a.push(s,n)}function Ce(i,t,e,r,s,n,a,o,h){if(h>Hi)return;const l=(t+r)/2,c=(e+s)/2,u=(r+n)/2,f=(s+a)/2,p=(l+u)/2,d=(c+f)/2;let x=n-t,g=a-e;const _=Math.abs((r-n)*g-(s-a)*x);if(_>Oi){if(_*_<=o*(x*x+g*g)){i.push(p,d);return}}else if(x=p-(t+n)/2,g=d-(e+a)/2,x*x+g*g<=o){i.push(p,d);return}Ce(i,t,e,l,c,p,d,o,h+1),Ce(i,p,d,u,f,n,a,o,h+1)}function jr(i,t,e,r,s,n,a,o){let h=Math.abs(s-n);(!a&&s>n||a&&n>s)&&(h=2*Math.PI-h),o=o||Math.max(6,Math.floor(6*Math.pow(r,1/3)*(h/Math.PI))),o=Math.max(o,3);let l=h/o,c=s;l*=a?-1:1;for(let u=0;u<o+1;u++){const f=Math.cos(c),p=Math.sin(c),d=t+f*r,x=e+p*r;i.push(d,x),c+=l}}function ji(i,t,e,r,s,n){const a=i[i.length-2],h=i[i.length-1]-e,l=a-t,c=s-e,u=r-t,f=Math.abs(h*u-l*c);if(f<1e-8||n===0){(i[i.length-2]!==t||i[i.length-1]!==e)&&i.push(t,e);return}const p=h*h+l*l,d=c*c+u*u,x=h*c+l*u,g=n*Math.sqrt(p)/f,_=n*Math.sqrt(d)/f,m=g*x/p,y=_*x/d,b=g*u+_*l,P=g*c+_*h,k=l*(_+m),T=h*(_+m),v=u*(g+y),S=c*(g+y),w=Math.atan2(T-P,k-b),G=Math.atan2(S-P,v-b);jr(i,b+t,P+e,n,w,G,l*c>u*h)}const zt=Math.PI*2,de={centerX:0,centerY:0,ang1:0,ang2:0},fe=({x:i,y:t},e,r,s,n,a,o,h)=>{i*=e,t*=r;const l=s*i-n*t,c=n*i+s*t;return h.x=l+a,h.y=c+o,h};function Yi(i,t){const e=t===-1.5707963267948966?-.551915024494:1.3333333333333333*Math.tan(t/4),r=t===1.5707963267948966?.551915024494:e,s=Math.cos(i),n=Math.sin(i),a=Math.cos(i+t),o=Math.sin(i+t);return[{x:s-n*r,y:n+s*r},{x:a+o*r,y:o-a*r},{x:a,y:o}]}const or=(i,t,e,r)=>{const s=i*r-t*e<0?-1:1;let n=i*e+t*r;return n>1&&(n=1),n<-1&&(n=-1),s*Math.acos(n)},Xi=(i,t,e,r,s,n,a,o,h,l,c,u,f)=>{const p=Math.pow(s,2),d=Math.pow(n,2),x=Math.pow(c,2),g=Math.pow(u,2);let _=p*d-p*g-d*x;_<0&&(_=0),_/=p*g+d*x,_=Math.sqrt(_)*(a===o?-1:1);const m=_*s/n*u,y=_*-n/s*c,b=l*m-h*y+(i+e)/2,P=h*m+l*y+(t+r)/2,k=(c-m)/s,T=(u-y)/n,v=(-c-m)/s,S=(-u-y)/n,w=or(1,0,k,T);let G=or(k,T,v,S);o===0&&G>0&&(G-=zt),o===1&&G<0&&(G+=zt),f.centerX=b,f.centerY=P,f.ang1=w,f.ang2=G};function qi(i,t,e,r,s,n,a,o=0,h=0,l=0){if(n===0||a===0)return;const c=Math.sin(o*zt/360),u=Math.cos(o*zt/360),f=u*(t-r)/2+c*(e-s)/2,p=-c*(t-r)/2+u*(e-s)/2;if(f===0&&p===0)return;n=Math.abs(n),a=Math.abs(a);const d=Math.pow(f,2)/Math.pow(n,2)+Math.pow(p,2)/Math.pow(a,2);d>1&&(n*=Math.sqrt(d),a*=Math.sqrt(d)),Xi(t,e,r,s,n,a,h,l,c,u,f,p,de);let{ang1:x,ang2:g}=de;const{centerX:_,centerY:m}=de;let y=Math.abs(g)/(zt/4);Math.abs(1-y)<1e-7&&(y=1);const b=Math.max(Math.ceil(y),1);g/=b;let P=i[i.length-2],k=i[i.length-1];const T={x:0,y:0};for(let v=0;v<b;v++){const S=Yi(x,g),{x:w,y:G}=fe(S[0],n,a,u,c,_,m,T),{x:Y,y:B}=fe(S[1],n,a,u,c,_,m,T),{x:C,y:I}=fe(S[2],n,a,u,c,_,m,T);Nr(i,P,k,w,G,Y,B,C,I),P=C,k=I,x+=g}}function Ki(i,t,e){const r=(a,o)=>{const h=o.x-a.x,l=o.y-a.y,c=Math.sqrt(h*h+l*l),u=h/c,f=l/c;return{len:c,nx:u,ny:f}},s=(a,o)=>{a===0?i.moveTo(o.x,o.y):i.lineTo(o.x,o.y)};let n=t[t.length-1];for(let a=0;a<t.length;a++){const o=t[a%t.length],h=o.radius??e;if(h<=0){s(a,o),n=o;continue}const l=t[(a+1)%t.length],c=r(o,n),u=r(o,l);if(c.len<1e-4||u.len<1e-4){s(a,o),n=o;continue}let f=Math.asin(c.nx*u.ny-c.ny*u.nx),p=1,d=!1;c.nx*u.nx-c.ny*-u.ny<0?f<0?f=Math.PI+f:(f=Math.PI-f,p=-1,d=!0):f>0&&(p=-1,d=!0);const x=f/2;let g,_=Math.abs(Math.cos(x)*h/Math.sin(x));_>Math.min(c.len/2,u.len/2)?(_=Math.min(c.len/2,u.len/2),g=Math.abs(_*Math.sin(x)/Math.cos(x))):g=h;const m=o.x+u.nx*_+-u.ny*g*p,y=o.y+u.ny*_+u.nx*g*p,b=Math.atan2(c.ny,c.nx)+Math.PI/2*p,P=Math.atan2(u.ny,u.nx)-Math.PI/2*p;a===0&&i.moveTo(m+Math.cos(b)*g,y+Math.sin(b)*g),i.arc(m,y,g,b,P,d),n=o}}function Qi(i,t,e,r){const s=(o,h)=>Math.sqrt((o.x-h.x)**2+(o.y-h.y)**2),n=(o,h,l)=>({x:o.x+(h.x-o.x)*l,y:o.y+(h.y-o.y)*l}),a=t.length;for(let o=0;o<a;o++){const h=t[(o+1)%a],l=h.radius??e;if(l<=0){o===0?i.moveTo(h.x,h.y):i.lineTo(h.x,h.y);continue}const c=t[o],u=t[(o+2)%a],f=s(c,h);let p;if(f<1e-4)p=h;else{const g=Math.min(f/2,l);p=n(h,c,g/f)}const d=s(u,h);let x;if(d<1e-4)x=h;else{const g=Math.min(d/2,l);x=n(h,u,g/d)}o===0?i.moveTo(p.x,p.y):i.lineTo(p.x,p.y),i.quadraticCurveTo(h.x,h.y,x.x,x.y,r)}}const Zi=new Q;class Ji{constructor(t){this.shapePrimitives=[],this._currentPoly=null,this._bounds=new Gt,this._graphicsPath2D=t}moveTo(t,e){return this.startPoly(t,e),this}lineTo(t,e){this._ensurePoly();const r=this._currentPoly.points,s=r[r.length-2],n=r[r.length-1];return(s!==t||n!==e)&&r.push(t,e),this}arc(t,e,r,s,n,a){this._ensurePoly(!1);const o=this._currentPoly.points;return jr(o,t,e,r,s,n,a),this}arcTo(t,e,r,s,n){this._ensurePoly();const a=this._currentPoly.points;return ji(a,t,e,r,s,n),this}arcToSvg(t,e,r,s,n,a,o){const h=this._currentPoly.points;return qi(h,this._currentPoly.lastX,this._currentPoly.lastY,a,o,t,e,r,s,n),this}bezierCurveTo(t,e,r,s,n,a,o){this._ensurePoly();const h=this._currentPoly;return Nr(this._currentPoly.points,h.lastX,h.lastY,t,e,r,s,n,a,o),this}quadraticCurveTo(t,e,r,s,n){this._ensurePoly();const a=this._currentPoly;return Vi(this._currentPoly.points,a.lastX,a.lastY,t,e,r,s,n),this}closePath(){return this.endPoly(!0),this}addPath(t,e){this.endPoly(),e&&!e.isIdentity()&&(t=t.clone(!0),t.transform(e));for(let r=0;r<t.instructions.length;r++){const s=t.instructions[r];this[s.action](...s.data)}return this}finish(t=!1){this.endPoly(t)}rect(t,e,r,s,n){return this.drawShape(new Q(t,e,r,s),n),this}circle(t,e,r,s){return this.drawShape(new Ae(t,e,r),s),this}poly(t,e,r){const s=new It(t);return s.closePath=e,this.drawShape(s,r),this}regularPoly(t,e,r,s,n=0,a){s=Math.max(s|0,3);const o=-1*Math.PI/2+n,h=Math.PI*2/s,l=[];for(let c=0;c<s;c++){const u=c*h+o;l.push(t+r*Math.cos(u),e+r*Math.sin(u))}return this.poly(l,!0,a),this}roundPoly(t,e,r,s,n,a=0,o){if(s=Math.max(s|0,3),n<=0)return this.regularPoly(t,e,r,s,a);const h=r*Math.sin(Math.PI/s)-.001;n=Math.min(n,h);const l=-1*Math.PI/2+a,c=Math.PI*2/s,u=(s-2)*Math.PI/s/2;for(let f=0;f<s;f++){const p=f*c+l,d=t+r*Math.cos(p),x=e+r*Math.sin(p),g=p+Math.PI+u,_=p-Math.PI-u,m=d+n*Math.cos(g),y=x+n*Math.sin(g),b=d+n*Math.cos(_),P=x+n*Math.sin(_);f===0?this.moveTo(m,y):this.lineTo(m,y),this.quadraticCurveTo(d,x,b,P,o)}return this.closePath()}roundShape(t,e,r=!1,s){return t.length<3?this:(r?Qi(this,t,e,s):Ki(this,t,e),this.closePath())}filletRect(t,e,r,s,n){if(n===0)return this.rect(t,e,r,s);const a=Math.min(r,s)/2,o=Math.min(a,Math.max(-a,n)),h=t+r,l=e+s,c=o<0?-o:0,u=Math.abs(o);return this.moveTo(t,e+u).arcTo(t+c,e+c,t+u,e,u).lineTo(h-u,e).arcTo(h-c,e+c,h,e+u,u).lineTo(h,l-u).arcTo(h-c,l-c,t+r-u,l,u).lineTo(t+u,l).arcTo(t+c,l-c,t,l-u,u).closePath()}chamferRect(t,e,r,s,n,a){if(n<=0)return this.rect(t,e,r,s);const o=Math.min(n,Math.min(r,s)/2),h=t+r,l=e+s,c=[t+o,e,h-o,e,h,e+o,h,l-o,h-o,l,t+o,l,t,l-o,t,e+o];for(let u=c.length-1;u>=2;u-=2)c[u]===c[u-2]&&c[u-1]===c[u-3]&&c.splice(u-1,2);return this.poly(c,!0,a)}ellipse(t,e,r,s,n){return this.drawShape(new Fe(t,e,r,s),n),this}roundRect(t,e,r,s,n,a){return this.drawShape(new Re(t,e,r,s,n),a),this}drawShape(t,e){return this.endPoly(),this.shapePrimitives.push({shape:t,transform:e}),this}startPoly(t,e){let r=this._currentPoly;return r&&this.endPoly(),r=new It,r.points.push(t,e),this._currentPoly=r,this}endPoly(t=!1){const e=this._currentPoly;return e&&e.points.length>2&&(e.closePath=t,this.shapePrimitives.push({shape:e})),this._currentPoly=null,this}_ensurePoly(t=!0){if(!this._currentPoly&&(this._currentPoly=new It,t)){const e=this.shapePrimitives[this.shapePrimitives.length-1];if(e){let r=e.shape.x,s=e.shape.y;if(!e.transform.isIdentity()){const n=e.transform,a=r;r=n.a*r+n.c*s+n.tx,s=n.b*a+n.d*s+n.ty}this._currentPoly.points.push(r,s)}else this._currentPoly.points.push(0,0)}}buildPath(){const t=this._graphicsPath2D;this.shapePrimitives.length=0,this._currentPoly=null;for(let e=0;e<t.instructions.length;e++){const r=t.instructions[e];this[r.action](...r.data)}this.finish()}get bounds(){const t=this._bounds;t.clear();const e=this.shapePrimitives;for(let r=0;r<e.length;r++){const s=e[r],n=s.shape.getBounds(Zi);s.transform?t.addRect(n,s.transform):t.addRect(n)}return t}}class wt{constructor(t){this.instructions=[],this.uid=K("graphicsPath"),this._dirty=!0,typeof t=="string"?li(t,this):this.instructions=(t==null?void 0:t.slice())??[]}get shapePath(){return this._shapePath||(this._shapePath=new Ji(this)),this._dirty&&(this._dirty=!1,this._shapePath.buildPath()),this._shapePath}addPath(t,e){return t=t.clone(),this.instructions.push({action:"addPath",data:[t,e]}),this._dirty=!0,this}arc(...t){return this.instructions.push({action:"arc",data:t}),this._dirty=!0,this}arcTo(...t){return this.instructions.push({action:"arcTo",data:t}),this._dirty=!0,this}arcToSvg(...t){return this.instructions.push({action:"arcToSvg",data:t}),this._dirty=!0,this}bezierCurveTo(...t){return this.instructions.push({action:"bezierCurveTo",data:t}),this._dirty=!0,this}bezierCurveToShort(t,e,r,s,n){const a=this.instructions[this.instructions.length-1],o=this.getLastPoint(gt.shared);let h=0,l=0;if(!a||a.action!=="bezierCurveTo")h=o.x,l=o.y;else{h=a.data[2],l=a.data[3];const c=o.x,u=o.y;h=c+(c-h),l=u+(u-l)}return this.instructions.push({action:"bezierCurveTo",data:[h,l,t,e,r,s,n]}),this._dirty=!0,this}closePath(){return this.instructions.push({action:"closePath",data:[]}),this._dirty=!0,this}ellipse(...t){return this.instructions.push({action:"ellipse",data:t}),this._dirty=!0,this}lineTo(...t){return this.instructions.push({action:"lineTo",data:t}),this._dirty=!0,this}moveTo(...t){return this.instructions.push({action:"moveTo",data:t}),this}quadraticCurveTo(...t){return this.instructions.push({action:"quadraticCurveTo",data:t}),this._dirty=!0,this}quadraticCurveToShort(t,e,r){const s=this.instructions[this.instructions.length-1],n=this.getLastPoint(gt.shared);let a=0,o=0;if(!s||s.action!=="quadraticCurveTo")a=n.x,o=n.y;else{a=s.data[0],o=s.data[1];const h=n.x,l=n.y;a=h+(h-a),o=l+(l-o)}return this.instructions.push({action:"quadraticCurveTo",data:[a,o,t,e,r]}),this._dirty=!0,this}rect(t,e,r,s,n){return this.instructions.push({action:"rect",data:[t,e,r,s,n]}),this._dirty=!0,this}circle(t,e,r,s){return this.instructions.push({action:"circle",data:[t,e,r,s]}),this._dirty=!0,this}roundRect(...t){return this.instructions.push({action:"roundRect",data:t}),this._dirty=!0,this}poly(...t){return this.instructions.push({action:"poly",data:t}),this._dirty=!0,this}regularPoly(...t){return this.instructions.push({action:"regularPoly",data:t}),this._dirty=!0,this}roundPoly(...t){return this.instructions.push({action:"roundPoly",data:t}),this._dirty=!0,this}roundShape(...t){return this.instructions.push({action:"roundShape",data:t}),this._dirty=!0,this}filletRect(...t){return this.instructions.push({action:"filletRect",data:t}),this._dirty=!0,this}chamferRect(...t){return this.instructions.push({action:"chamferRect",data:t}),this._dirty=!0,this}star(t,e,r,s,n,a,o){n=n||s/2;const h=-1*Math.PI/2+a,l=r*2,c=Math.PI*2/l,u=[];for(let f=0;f<l;f++){const p=f%2?n:s,d=f*c+h;u.push(t+p*Math.cos(d),e+p*Math.sin(d))}return this.poly(u,!0,o),this}clone(t=!1){const e=new wt;if(!t)e.instructions=this.instructions.slice();else for(let r=0;r<this.instructions.length;r++){const s=this.instructions[r];e.instructions.push({action:s.action,data:s.data.slice()})}return e}clear(){return this.instructions.length=0,this._dirty=!0,this}transform(t){if(t.isIdentity())return this;const e=t.a,r=t.b,s=t.c,n=t.d,a=t.tx,o=t.ty;let h=0,l=0,c=0,u=0,f=0,p=0,d=0,x=0;for(let g=0;g<this.instructions.length;g++){const _=this.instructions[g],m=_.data;switch(_.action){case"moveTo":case"lineTo":h=m[0],l=m[1],m[0]=e*h+s*l+a,m[1]=r*h+n*l+o;break;case"bezierCurveTo":c=m[0],u=m[1],f=m[2],p=m[3],h=m[4],l=m[5],m[0]=e*c+s*u+a,m[1]=r*c+n*u+o,m[2]=e*f+s*p+a,m[3]=r*f+n*p+o,m[4]=e*h+s*l+a,m[5]=r*h+n*l+o;break;case"quadraticCurveTo":c=m[0],u=m[1],h=m[2],l=m[3],m[0]=e*c+s*u+a,m[1]=r*c+n*u+o,m[2]=e*h+s*l+a,m[3]=r*h+n*l+o;break;case"arcToSvg":h=m[5],l=m[6],d=m[0],x=m[1],m[0]=e*d+s*x,m[1]=r*d+n*x,m[5]=e*h+s*l+a,m[6]=r*h+n*l+o;break;case"circle":m[4]=Ft(m[3],t);break;case"rect":m[4]=Ft(m[4],t);break;case"ellipse":m[8]=Ft(m[8],t);break;case"roundRect":m[5]=Ft(m[5],t);break;case"addPath":m[0].transform(t);break;case"poly":m[2]=Ft(m[2],t);break;default:ot("unknown transform action",_.action);break}}return this._dirty=!0,this}get bounds(){return this.shapePath.bounds}getLastPoint(t){let e=this.instructions.length-1,r=this.instructions[e];if(!r)return t.x=0,t.y=0,t;for(;r.action==="closePath";){if(e--,e<0)return t.x=0,t.y=0,t;r=this.instructions[e]}switch(r.action){case"moveTo":case"lineTo":t.x=r.data[0],t.y=r.data[1];break;case"quadraticCurveTo":t.x=r.data[2],t.y=r.data[3];break;case"bezierCurveTo":t.x=r.data[4],t.y=r.data[5];break;case"arc":case"arcToSvg":t.x=r.data[5],t.y=r.data[6];break;case"addPath":r.data[0].getLastPoint(t);break}return t}}function Ft(i,t){return i?i.prepend(t):t.clone()}function tn(i,t){if(typeof i=="string"){const r=document.createElement("div");r.innerHTML=i.trim(),i=r.querySelector("svg")}const e={context:t,path:new wt};return Yr(i,e,null,null),t}function Yr(i,t,e,r){const s=i.children,{fillStyle:n,strokeStyle:a}=en(i);n&&e?e={...e,...n}:n&&(e=n),a&&r?r={...r,...a}:a&&(r=a),t.context.fillStyle=e,t.context.strokeStyle=r;let o,h,l,c,u,f,p,d,x,g,_,m,y,b,P,k,T;switch(i.nodeName.toLowerCase()){case"path":b=i.getAttribute("d"),P=new wt(b),t.context.path(P),e&&t.context.fill(),r&&t.context.stroke();break;case"circle":p=$(i,"cx",0),d=$(i,"cy",0),x=$(i,"r",0),t.context.ellipse(p,d,x,x),e&&t.context.fill(),r&&t.context.stroke();break;case"rect":o=$(i,"x",0),h=$(i,"y",0),k=$(i,"width",0),T=$(i,"height",0),g=$(i,"rx",0),_=$(i,"ry",0),g||_?t.context.roundRect(o,h,k,T,g||_):t.context.rect(o,h,k,T),e&&t.context.fill(),r&&t.context.stroke();break;case"ellipse":p=$(i,"cx",0),d=$(i,"cy",0),g=$(i,"rx",0),_=$(i,"ry",0),t.context.beginPath(),t.context.ellipse(p,d,g,_),e&&t.context.fill(),r&&t.context.stroke();break;case"line":l=$(i,"x1",0),c=$(i,"y1",0),u=$(i,"x2",0),f=$(i,"y2",0),t.context.beginPath(),t.context.moveTo(l,c),t.context.lineTo(u,f),r&&t.context.stroke();break;case"polygon":y=i.getAttribute("points"),m=y.match(/\d+/g).map(v=>parseInt(v,10)),t.context.poly(m,!0),e&&t.context.fill(),r&&t.context.stroke();break;case"polyline":y=i.getAttribute("points"),m=y.match(/\d+/g).map(v=>parseInt(v,10)),t.context.poly(m,!1),r&&t.context.stroke();break;case"g":case"svg":break;default:{console.info(`[SVG parser] <${i.nodeName}> elements unsupported`);break}}for(let v=0;v<s.length;v++)Yr(s[v],t,e,r)}function $(i,t,e){const r=i.getAttribute(t);return r?Number(r):e}function en(i){const t=i.getAttribute("style"),e={},r={};let s=!1,n=!1;if(t){const a=t.split(";");for(let o=0;o<a.length;o++){const h=a[o],[l,c]=h.split(":");switch(l){case"stroke":c!=="none"&&(e.color=H.shared.setValue(c).toNumber(),n=!0);break;case"stroke-width":e.width=Number(c);break;case"fill":c!=="none"&&(s=!0,r.color=H.shared.setValue(c).toNumber());break;case"fill-opacity":r.alpha=Number(c);break;case"stroke-opacity":e.alpha=Number(c);break;case"opacity":r.alpha=Number(c),e.alpha=Number(c);break}}}else{const a=i.getAttribute("stroke");a&&a!=="none"&&(n=!0,e.color=H.shared.setValue(a).toNumber(),e.width=$(i,"stroke-width",1));const o=i.getAttribute("fill");o&&o!=="none"&&(s=!0,r.color=H.shared.setValue(o).toNumber())}return{strokeStyle:n?e:null,fillStyle:s?r:null}}const Xr=class Me{constructor(t,e,r,s){this.uid=K("fillGradient"),this.type="linear",this.gradientStops=[],this.x0=t,this.y0=e,this.x1=r,this.y1=s}addColorStop(t,e){return this.gradientStops.push({offset:t,color:H.shared.setValue(e).toHex()}),this}buildLinearGradient(){const t=Me.defaultTextureSize,{gradientStops:e}=this,r=q.get().createCanvas();r.width=t,r.height=t;const s=r.getContext("2d"),n=s.createLinearGradient(0,0,Me.defaultTextureSize,1);for(let x=0;x<e.length;x++){const g=e[x];n.addColorStop(g.offset,g.color)}s.fillStyle=n,s.fillRect(0,0,t,t),this.texture=new O({source:new Br({resource:r,addressModeU:"clamp-to-edge",addressModeV:"repeat"})});const{x0:a,y0:o,x1:h,y1:l}=this,c=new V,u=h-a,f=l-o,p=Math.sqrt(u*u+f*f),d=Math.atan2(f,u);c.translate(-a,-o),c.scale(1/t,1/t),c.rotate(-d),c.scale(256/p,1),this.transform=c}};Xr.defaultTextureSize=256;let De=Xr;const hr={repeat:{addressModeU:"repeat",addressModeV:"repeat"},"repeat-x":{addressModeU:"repeat",addressModeV:"clamp-to-edge"},"repeat-y":{addressModeU:"clamp-to-edge",addressModeV:"repeat"},"no-repeat":{addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}};class qr{constructor(t,e){this.uid=K("fillPattern"),this.transform=new V,this.texture=t,this.transform.scale(1/t.frame.width,1/t.frame.height),e&&(t.source.style.addressModeU=hr[e].addressModeU,t.source.style.addressModeV=hr[e].addressModeV)}setTransform(t){const e=this.texture;this.transform.copyFrom(t),this.transform.invert(),this.transform.scale(1/e.frame.width,1/e.frame.height)}}function it(i,t){var a;if(i==null)return null;let e,r;if(i!=null&&i.fill?(r=i.fill,e={...t,...i}):(r=i,e=t),H.isColorLike(r)){const o=H.shared.setValue(r??0);return{...e,color:o.toNumber(),alpha:o.alpha===1?e.alpha:o.alpha,texture:O.WHITE}}else if(r instanceof qr){const o=r;return{...e,color:16777215,texture:o.texture,matrix:o.transform,fill:e.fill??null}}else if(r instanceof De){const o=r;return o.buildLinearGradient(),{...e,color:16777215,texture:o.texture,matrix:o.transform}}const s={...t,...i};if(s.texture){if(s.texture!==O.WHITE){const h=((a=s.matrix)==null?void 0:a.invert())||new V;h.scale(1/s.texture.frame.width,1/s.texture.frame.height),s.matrix=h}const o=s.texture.source.style;o.addressMode==="clamp-to-edge"&&(o.addressMode="repeat")}const n=H.shared.setValue(s.color);return s.alpha*=n.alpha,s.color=n.toNumber(),s.matrix=s.matrix?s.matrix.clone():null,s}const rn=new gt,cr=new V,We=class J extends vt{constructor(){super(...arguments),this.uid=K("graphicsContext"),this.dirty=!0,this.batchMode="auto",this.instructions=[],this._activePath=new wt,this._transform=new V,this._fillStyle={...J.defaultFillStyle},this._strokeStyle={...J.defaultStrokeStyle},this._stateStack=[],this._tick=0,this._bounds=new Gt,this._boundsDirty=!0}clone(){const t=new J;return t.batchMode=this.batchMode,t.instructions=this.instructions.slice(),t._activePath=this._activePath.clone(),t._transform=this._transform.clone(),t._fillStyle={...this._fillStyle},t._strokeStyle={...this._strokeStyle},t._stateStack=this._stateStack.slice(),t._bounds=this._bounds.clone(),t._boundsDirty=!0,t}get fillStyle(){return this._fillStyle}set fillStyle(t){this._fillStyle=it(t,J.defaultFillStyle)}get strokeStyle(){return this._strokeStyle}set strokeStyle(t){this._strokeStyle=it(t,J.defaultStrokeStyle)}setFillStyle(t){return this._fillStyle=it(t,J.defaultFillStyle),this}setStrokeStyle(t){return this._strokeStyle=it(t,J.defaultStrokeStyle),this}texture(t,e,r,s,n,a){return this.instructions.push({action:"texture",data:{image:t,dx:r||0,dy:s||0,dw:n||t.frame.width,dh:a||t.frame.height,transform:this._transform.clone(),alpha:this._fillStyle.alpha,style:e?H.shared.setValue(e).toNumber():16777215}}),this.onUpdate(),this}beginPath(){return this._activePath=new wt,this}fill(t,e){let r;const s=this.instructions[this.instructions.length-1];return this._tick===0&&s&&s.action==="stroke"?r=s.data.path:r=this._activePath.clone(),r?(t!=null&&(e!==void 0&&typeof t=="number"&&(E(D,"GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead"),t={color:t,alpha:e}),this._fillStyle=it(t,J.defaultFillStyle)),this.instructions.push({action:"fill",data:{style:this.fillStyle,path:r}}),this.onUpdate(),this._initNextPathLocation(),this._tick=0,this):this}_initNextPathLocation(){const{x:t,y:e}=this._activePath.getLastPoint(gt.shared);this._activePath.clear(),this._activePath.moveTo(t,e)}stroke(t){let e;const r=this.instructions[this.instructions.length-1];return this._tick===0&&r&&r.action==="fill"?e=r.data.path:e=this._activePath.clone(),e?(t!=null&&(this._strokeStyle=it(t,J.defaultStrokeStyle)),this.instructions.push({action:"stroke",data:{style:this.strokeStyle,path:e}}),this.onUpdate(),this._initNextPathLocation(),this._tick=0,this):this}cut(){for(let t=0;t<2;t++){const e=this.instructions[this.instructions.length-1-t],r=this._activePath.clone();if(e&&(e.action==="stroke"||e.action==="fill"))if(e.data.hole)e.data.hole.addPath(r);else{e.data.hole=r;break}}return this._initNextPathLocation(),this}arc(t,e,r,s,n,a){this._tick++;const o=this._transform;return this._activePath.arc(o.a*t+o.c*e+o.tx,o.b*t+o.d*e+o.ty,r,s,n,a),this}arcTo(t,e,r,s,n){this._tick++;const a=this._transform;return this._activePath.arcTo(a.a*t+a.c*e+a.tx,a.b*t+a.d*e+a.ty,a.a*r+a.c*s+a.tx,a.b*r+a.d*s+a.ty,n),this}arcToSvg(t,e,r,s,n,a,o){this._tick++;const h=this._transform;return this._activePath.arcToSvg(t,e,r,s,n,h.a*a+h.c*o+h.tx,h.b*a+h.d*o+h.ty),this}bezierCurveTo(t,e,r,s,n,a,o){this._tick++;const h=this._transform;return this._activePath.bezierCurveTo(h.a*t+h.c*e+h.tx,h.b*t+h.d*e+h.ty,h.a*r+h.c*s+h.tx,h.b*r+h.d*s+h.ty,h.a*n+h.c*a+h.tx,h.b*n+h.d*a+h.ty,o),this}closePath(){var t;return this._tick++,(t=this._activePath)==null||t.closePath(),this}ellipse(t,e,r,s){return this._tick++,this._activePath.ellipse(t,e,r,s,this._transform.clone()),this}circle(t,e,r){return this._tick++,this._activePath.circle(t,e,r,this._transform.clone()),this}path(t){return this._tick++,this._activePath.addPath(t,this._transform.clone()),this}lineTo(t,e){this._tick++;const r=this._transform;return this._activePath.lineTo(r.a*t+r.c*e+r.tx,r.b*t+r.d*e+r.ty),this}moveTo(t,e){this._tick++;const r=this._transform,s=this._activePath.instructions,n=r.a*t+r.c*e+r.tx,a=r.b*t+r.d*e+r.ty;return s.length===1&&s[0].action==="moveTo"?(s[0].data[0]=n,s[0].data[1]=a,this):(this._activePath.moveTo(n,a),this)}quadraticCurveTo(t,e,r,s,n){this._tick++;const a=this._transform;return this._activePath.quadraticCurveTo(a.a*t+a.c*e+a.tx,a.b*t+a.d*e+a.ty,a.a*r+a.c*s+a.tx,a.b*r+a.d*s+a.ty,n),this}rect(t,e,r,s){return this._tick++,this._activePath.rect(t,e,r,s,this._transform.clone()),this}roundRect(t,e,r,s,n){return this._tick++,this._activePath.roundRect(t,e,r,s,n,this._transform.clone()),this}poly(t,e){return this._tick++,this._activePath.poly(t,e,this._transform.clone()),this}regularPoly(t,e,r,s,n=0,a){return this._tick++,this._activePath.regularPoly(t,e,r,s,n,a),this}roundPoly(t,e,r,s,n,a){return this._tick++,this._activePath.roundPoly(t,e,r,s,n,a),this}roundShape(t,e,r,s){return this._tick++,this._activePath.roundShape(t,e,r,s),this}filletRect(t,e,r,s,n){return this._tick++,this._activePath.filletRect(t,e,r,s,n),this}chamferRect(t,e,r,s,n,a){return this._tick++,this._activePath.chamferRect(t,e,r,s,n,a),this}star(t,e,r,s,n=0,a=0){return this._tick++,this._activePath.star(t,e,r,s,n,a,this._transform.clone()),this}svg(t){return this._tick++,tn(t,this),this}restore(){const t=this._stateStack.pop();return t&&(this._transform=t.transform,this._fillStyle=t.fillStyle,this._strokeStyle=t.strokeStyle),this}save(){return this._stateStack.push({transform:this._transform.clone(),fillStyle:{...this._fillStyle},strokeStyle:{...this._strokeStyle}}),this}getTransform(){return this._transform}resetTransform(){return this._transform.identity(),this}rotate(t){return this._transform.rotate(t),this}scale(t,e=t){return this._transform.scale(t,e),this}setTransform(t,e,r,s,n,a){return t instanceof V?(this._transform.set(t.a,t.b,t.c,t.d,t.tx,t.ty),this):(this._transform.set(t,e,r,s,n,a),this)}transform(t,e,r,s,n,a){return t instanceof V?(this._transform.append(t),this):(cr.set(t,e,r,s,n,a),this._transform.append(cr),this)}translate(t,e=t){return this._transform.translate(t,e),this}clear(){return this.instructions.length=0,this.resetTransform(),this.onUpdate(),this}onUpdate(){this.dirty||(this.emit("update",this,16),this.dirty=!0,this._boundsDirty=!0)}get bounds(){if(!this._boundsDirty)return this._bounds;const t=this._bounds;t.clear();for(let e=0;e<this.instructions.length;e++){const r=this.instructions[e],s=r.action;if(s==="fill"){const n=r.data;t.addBounds(n.path.bounds)}else if(s==="texture"){const n=r.data;t.addFrame(n.dx,n.dy,n.dx+n.dw,n.dy+n.dh,n.transform)}if(s==="stroke"){const n=r.data,a=n.style.width/2,o=n.path.bounds;t.addFrame(o.minX-a,o.minY-a,o.maxX+a,o.maxY+a)}}return t}containsPoint(t){var s;if(!this.bounds.containsPoint(t.x,t.y))return!1;const e=this.instructions;let r=!1;for(let n=0;n<e.length;n++){const a=e[n],o=a.data,h=o.path;if(!a.action||!h)continue;const l=o.style,c=h.shapePath.shapePrimitives;for(let u=0;u<c.length;u++){const f=c[u].shape;if(!l||!f)continue;const p=c[u].transform,d=p?p.applyInverse(t,rn):t;a.action==="fill"?r=f.contains(d.x,d.y):r=f.strokeContains(d.x,d.y,l.width);const x=o.hole;if(x){const g=(s=x.shapePath)==null?void 0:s.shapePrimitives;if(g)for(let _=0;_<g.length;_++)g[_].shape.contains(d.x,d.y)&&(r=!1)}if(r)return!0}}return r}destroy(t=!1){if(this._stateStack.length=0,this._transform=null,this.emit("destroy",this),this.removeAllListeners(),typeof t=="boolean"?t:t==null?void 0:t.texture){const r=typeof t=="boolean"?t:t==null?void 0:t.textureSource;this._fillStyle.texture&&this._fillStyle.texture.destroy(r),this._strokeStyle.texture&&this._strokeStyle.texture.destroy(r)}this._fillStyle=null,this._strokeStyle=null,this.instructions=null,this._activePath=null,this._bounds=null,this._stateStack=null,this.customShader=null,this._transform=null}};We.defaultFillStyle={color:16777215,alpha:1,texture:O.WHITE,matrix:null,fill:null};We.defaultStrokeStyle={width:1,color:16777215,alpha:1,alignment:.5,miterLimit:10,cap:"butt",join:"miter",texture:O.WHITE,matrix:null,fill:null};let ft=We,sn=0;class nn{constructor(t){this._poolKeyHash=Object.create(null),this._texturePool={},this.textureOptions=t||{},this.enableFullScreen=!1}createTexture(t,e,r){const s=new Ds({...this.textureOptions,width:t,height:e,resolution:1,antialias:r,autoGarbageCollect:!0});return new O({source:s,label:`texturePool_${sn++}`})}getOptimalTexture(t,e,r=1,s){let n=Math.ceil(t*r-1e-6),a=Math.ceil(e*r-1e-6);n=bt(n),a=bt(a);const o=(n<<17)+(a<<1)+(s?1:0);this._texturePool[o]||(this._texturePool[o]=[]);let h=this._texturePool[o].pop();return h||(h=this.createTexture(n,a,s)),h.source._resolution=r,h.source.width=n/r,h.source.height=a/r,h.source.pixelWidth=n,h.source.pixelHeight=a,h.frame.x=0,h.frame.y=0,h.frame.width=t,h.frame.height=e,h.updateUvs(),this._poolKeyHash[h.uid]=o,h}getSameSizeTexture(t,e=!1){const r=t.source;return this.getOptimalTexture(t.width,t.height,r._resolution,e)}returnTexture(t){const e=this._poolKeyHash[t.uid];this._texturePool[e].push(t)}clear(t){if(t=t!==!1,t)for(const e in this._texturePool){const r=this._texturePool[e];if(r)for(let s=0;s<r.length;s++)r[s].destroy(!0)}this._texturePool={}}}const tt=new nn;class Kr{constructor(t){this._renderer=t}push(t,e,r){this._renderer.renderPipes.batch.break(r),r.add({renderPipeId:"filter",canBundle:!1,action:"pushFilter",container:e,filterEffect:t})}pop(t,e,r){this._renderer.renderPipes.batch.break(r),r.add({renderPipeId:"filter",action:"popFilter",canBundle:!1})}execute(t){t.action==="pushFilter"?this._renderer.filter.push(t):t.action==="popFilter"&&this._renderer.filter.pop()}destroy(){this._renderer=null}}Kr.extension={type:[R.WebGLPipes,R.WebGPUPipes,R.CanvasPipes],name:"filter"};const an=new V;function on(i,t){return t.clear(),Qr(i,t),t.isValid||t.set(0,0,0,0),i.renderGroup?t.applyMatrix(i.renderGroup.localTransform):t.applyMatrix(i.parentRenderGroup.worldTransform),t}function Qr(i,t){if(i.localDisplayStatus!==7||!i.measurable)return;const e=!!i.effects.length;let r=t;if((i.renderGroup||e)&&(r=Qt.get().clear()),i.boundsArea)t.addRect(i.boundsArea,i.worldTransform);else{if(i.renderPipeId){const n=i.bounds;r.addFrame(n.minX,n.minY,n.maxX,n.maxY,i.groupTransform)}const s=i.children;for(let n=0;n<s.length;n++)Qr(s[n],r)}if(e){let s=!1;for(let n=0;n<i.effects.length;n++)i.effects[n].addBounds&&(s||(s=!0,r.applyMatrix(i.parentRenderGroup.worldTransform)),i.effects[n].addBounds(r,!0));s&&(r.applyMatrix(i.parentRenderGroup.worldTransform.copyTo(an).invert()),t.addBounds(r,i.relativeGroupTransform)),t.addBounds(r),Qt.return(r)}else i.renderGroup&&(t.addBounds(r,i.relativeGroupTransform),Qt.return(r))}function hn(i,t){t.clear();const e=t.matrix;for(let r=0;r<i.length;r++){const s=i[r];s.globalDisplayStatus<7||(t.matrix=s.worldTransform,s.addBounds(t))}return t.matrix=e,t}const cn=new Ie({attributes:{aPosition:{buffer:new Float32Array([0,0,1,0,1,1,0,1]),location:0,format:"float32x2",stride:2*4,offset:0}},indexBuffer:new Uint32Array([0,1,2,0,2,3])});class Zr{constructor(t){this._filterStackIndex=0,this._filterStack=[],this._filterGlobalUniforms=new mt({uInputSize:{value:new Float32Array(4),type:"vec4<f32>"},uInputPixel:{value:new Float32Array(4),type:"vec4<f32>"},uInputClamp:{value:new Float32Array(4),type:"vec4<f32>"},uOutputFrame:{value:new Float32Array(4),type:"vec4<f32>"},uGlobalFrame:{value:new Float32Array(4),type:"vec4<f32>"},uOutputTexture:{value:new Float32Array(4),type:"vec4<f32>"}}),this._globalFilterBindGroup=new yt({}),this.renderer=t}get activeBackTexture(){var t;return(t=this._activeFilterData)==null?void 0:t.backTexture}push(t){var p;const e=this.renderer,r=t.filterEffect.filters;this._filterStack[this._filterStackIndex]||(this._filterStack[this._filterStackIndex]=this._getFilterData());const s=this._filterStack[this._filterStackIndex];if(this._filterStackIndex++,r.length===0){s.skip=!0;return}const n=s.bounds;t.renderables?hn(t.renderables,n):t.filterEffect.filterArea?(n.clear(),n.addRect(t.filterEffect.filterArea),n.applyMatrix(t.container.worldTransform)):on(t.container,n);const a=e.renderTarget.rootRenderTarget.colorTexture.source;let o=a._resolution,h=0,l=a.antialias,c=!1,u=!1;for(let d=0;d<r.length;d++){const x=r[d];if(o=Math.min(o,x.resolution),h+=x.padding,x.antialias!=="inherit"&&(x.antialias==="on"?l=!0:l=!1),!!!(x.compatibleRenderers&e.type)){u=!1;break}if(x.blendRequired&&!(((p=e.backBuffer)==null?void 0:p.useBackBuffer)??!0)){ot("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options."),u=!1;break}u=x.enabled||u,c=c||x.blendRequired}if(!u){s.skip=!0;return}const f=e.renderTarget.rootViewPort;if(n.scale(o).fitBounds(0,f.width,0,f.height).scale(1/o).pad(h).ceil(),!n.isPositive){s.skip=!0;return}s.skip=!1,s.bounds=n,s.blendRequired=c,s.container=t.container,s.filterEffect=t.filterEffect,s.previousRenderSurface=e.renderTarget.renderSurface,s.inputTexture=tt.getOptimalTexture(n.width,n.height,o,l),e.renderTarget.bind(s.inputTexture,!0),e.globalUniforms.push({offset:n})}pop(){const t=this.renderer;this._filterStackIndex--;const e=this._filterStack[this._filterStackIndex];if(e.skip)return;this._activeFilterData=e;const r=e.inputTexture,s=e.bounds;let n=O.EMPTY;if(t.renderTarget.finishRenderPass(),e.blendRequired){const o=this._filterStackIndex>0?this._filterStack[this._filterStackIndex-1].bounds:null,h=t.renderTarget.getRenderTarget(e.previousRenderSurface);n=this.getBackTexture(h,s,o)}e.backTexture=n;const a=e.filterEffect.filters;if(this._globalFilterBindGroup.setResource(r.source.style,2),this._globalFilterBindGroup.setResource(n.source,3),t.globalUniforms.pop(),a.length===1)a[0].apply(this,r,e.previousRenderSurface,!1),tt.returnTexture(r);else{let o=e.inputTexture,h=tt.getOptimalTexture(s.width,s.height,o.source._resolution,!1),l=0;for(l=0;l<a.length-1;++l){a[l].apply(this,o,h,!0);const u=o;o=h,h=u}a[l].apply(this,o,e.previousRenderSurface,!1),tt.returnTexture(o),tt.returnTexture(h)}e.blendRequired&&tt.returnTexture(n)}getBackTexture(t,e,r){const s=t.colorTexture.source._resolution,n=tt.getOptimalTexture(e.width,e.height,s,!1);let a=e.minX,o=e.minY;r&&(a-=r.minX,o-=r.minY),a=Math.floor(a*s),o=Math.floor(o*s);const h=Math.ceil(e.width*s),l=Math.ceil(e.height*s);return this.renderer.renderTarget.copyToTexture(t,n,{x:a,y:o},{width:h,height:l},{x:0,y:0}),n}applyFilter(t,e,r,s){const n=this.renderer,a=this._filterStack[this._filterStackIndex],o=a.bounds,h=gt.shared,c=a.previousRenderSurface===r;let u=this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution,f=this._filterStackIndex-1;for(;f>0&&this._filterStack[f].skip;)--f;f>0&&(u=this._filterStack[f].inputTexture.source._resolution);const p=this._filterGlobalUniforms,d=p.uniforms,x=d.uOutputFrame,g=d.uInputSize,_=d.uInputPixel,m=d.uInputClamp,y=d.uGlobalFrame,b=d.uOutputTexture;if(c){let T=this._filterStackIndex;for(;T>0;){T--;const v=this._filterStack[this._filterStackIndex-1];if(!v.skip){h.x=v.bounds.minX,h.y=v.bounds.minY;break}}x[0]=o.minX-h.x,x[1]=o.minY-h.y}else x[0]=0,x[1]=0;x[2]=e.frame.width,x[3]=e.frame.height,g[0]=e.source.width,g[1]=e.source.height,g[2]=1/g[0],g[3]=1/g[1],_[0]=e.source.pixelWidth,_[1]=e.source.pixelHeight,_[2]=1/_[0],_[3]=1/_[1],m[0]=.5*_[2],m[1]=.5*_[3],m[2]=e.frame.width*g[2]-.5*_[2],m[3]=e.frame.height*g[3]-.5*_[3];const P=this.renderer.renderTarget.rootRenderTarget.colorTexture;y[0]=h.x*u,y[1]=h.y*u,y[2]=P.source.width*u,y[3]=P.source.height*u;const k=this.renderer.renderTarget.getRenderTarget(r);if(n.renderTarget.bind(r,!!s),r instanceof O?(b[0]=r.frame.width,b[1]=r.frame.height):(b[0]=k.width,b[1]=k.height),b[2]=k.isRoot?-1:1,p.update(),n.renderPipes.uniformBatch){const T=n.renderPipes.uniformBatch.getUboResource(p);this._globalFilterBindGroup.setResource(T,0)}else this._globalFilterBindGroup.setResource(p,0);this._globalFilterBindGroup.setResource(e.source,1),this._globalFilterBindGroup.setResource(e.source.style,2),t.groups[0]=this._globalFilterBindGroup,n.encoder.draw({geometry:cn,shader:t,state:t._state,topology:"triangle-list"}),n.type===St.WEBGL&&n.renderTarget.finishRenderPass()}_getFilterData(){return{skip:!1,inputTexture:null,bounds:new Gt,container:null,filterEffect:null,blendRequired:!1,previousRenderSurface:null}}calculateSpriteMatrix(t,e){const r=this._activeFilterData,s=t.set(r.inputTexture._source.width,0,0,r.inputTexture._source.height,r.bounds.minX,r.bounds.minY),n=e.worldTransform.copyTo(V.shared);return n.invert(),s.prepend(n),s.scale(1/e.texture.frame.width,1/e.texture.frame.height),s.translate(e.anchor.x,e.anchor.y),s}}Zr.extension={type:[R.WebGLSystem,R.WebGPUSystem],name:"filter"};class Nt extends Ws{constructor(t){t instanceof ft&&(t={context:t});const{context:e,roundPixels:r,...s}=t||{};super({label:"Graphics",...s}),this.canBundle=!0,this.renderPipeId="graphics",this._roundPixels=0,e?this._context=e:this._context=this._ownedContext=new ft,this._context.on("update",this.onViewUpdate,this),this.allowChildren=!1,this.roundPixels=r??!1}set context(t){t!==this._context&&(this._context.off("update",this.onViewUpdate,this),this._context=t,this._context.on("update",this.onViewUpdate,this),this.onViewUpdate())}get context(){return this._context}get bounds(){return this._context.bounds}addBounds(t){t.addBounds(this._context.bounds)}containsPoint(t){return this._context.containsPoint(t)}get roundPixels(){return!!this._roundPixels}set roundPixels(t){this._roundPixels=t?1:0}onViewUpdate(){if(this._didChangeId+=4096,this._didGraphicsUpdate=!0,this.didViewUpdate)return;this.didViewUpdate=!0;const t=this.renderGroup||this.parentRenderGroup;t&&t.onChildViewUpdate(this)}destroy(t){this._ownedContext&&!t?this._ownedContext.destroy(t):(t===!0||(t==null?void 0:t.context)===!0)&&this._context.destroy(t),this._ownedContext=null,this._context=null,super.destroy(t)}_callContextMethod(t,e){return this.context[t](...e),this}setFillStyle(...t){return this._callContextMethod("setFillStyle",t)}setStrokeStyle(...t){return this._callContextMethod("setStrokeStyle",t)}fill(...t){return this._callContextMethod("fill",t)}stroke(...t){return this._callContextMethod("stroke",t)}texture(...t){return this._callContextMethod("texture",t)}beginPath(){return this._callContextMethod("beginPath",[])}cut(){return this._callContextMethod("cut",[])}arc(...t){return this._callContextMethod("arc",t)}arcTo(...t){return this._callContextMethod("arcTo",t)}arcToSvg(...t){return this._callContextMethod("arcToSvg",t)}bezierCurveTo(...t){return this._callContextMethod("bezierCurveTo",t)}closePath(){return this._callContextMethod("closePath",[])}ellipse(...t){return this._callContextMethod("ellipse",t)}circle(...t){return this._callContextMethod("circle",t)}path(...t){return this._callContextMethod("path",t)}lineTo(...t){return this._callContextMethod("lineTo",t)}moveTo(...t){return this._callContextMethod("moveTo",t)}quadraticCurveTo(...t){return this._callContextMethod("quadraticCurveTo",t)}rect(...t){return this._callContextMethod("rect",t)}roundRect(...t){return this._callContextMethod("roundRect",t)}poly(...t){return this._callContextMethod("poly",t)}regularPoly(...t){return this._callContextMethod("regularPoly",t)}roundPoly(...t){return this._callContextMethod("roundPoly",t)}roundShape(...t){return this._callContextMethod("roundShape",t)}filletRect(...t){return this._callContextMethod("filletRect",t)}chamferRect(...t){return this._callContextMethod("chamferRect",t)}star(...t){return this._callContextMethod("star",t)}svg(...t){return this._callContextMethod("svg",t)}restore(...t){return this._callContextMethod("restore",t)}save(){return this._callContextMethod("save",[])}getTransform(){return this.context.getTransform()}resetTransform(){return this._callContextMethod("resetTransform",[])}rotateTransform(...t){return this._callContextMethod("rotate",t)}scaleTransform(...t){return this._callContextMethod("scale",t)}setTransform(...t){return this._callContextMethod("setTransform",t)}transform(...t){return this._callContextMethod("transform",t)}translateTransform(...t){return this._callContextMethod("translate",t)}clear(){return this._callContextMethod("clear",[])}get fillStyle(){return this._context.fillStyle}set fillStyle(t){this._context.fillStyle=t}get strokeStyle(){return this._context.strokeStyle}set strokeStyle(t){this._context.strokeStyle=t}clone(t=!1){return t?new Nt(this._context.clone()):(this._ownedContext=null,new Nt(this._context))}lineStyle(t,e,r){E(D,"Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");const s={};return t&&(s.width=t),e&&(s.color=e),r&&(s.alpha=r),this.context.strokeStyle=s,this}beginFill(t,e){E(D,"Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");const r={};return t&&(r.color=t),e&&(r.alpha=e),this.context.fillStyle=r,this}endFill(){E(D,"Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."),this.context.fill();const t=this.context.strokeStyle;return(t.width!==ft.defaultStrokeStyle.width||t.color!==ft.defaultStrokeStyle.color||t.alpha!==ft.defaultStrokeStyle.alpha)&&this.context.stroke(),this}drawCircle(...t){return E(D,"Graphics#drawCircle has been renamed to Graphics#circle"),this._callContextMethod("circle",t)}drawEllipse(...t){return E(D,"Graphics#drawEllipse has been renamed to Graphics#ellipse"),this._callContextMethod("ellipse",t)}drawPolygon(...t){return E(D,"Graphics#drawPolygon has been renamed to Graphics#poly"),this._callContextMethod("poly",t)}drawRect(...t){return E(D,"Graphics#drawRect has been renamed to Graphics#rect"),this._callContextMethod("rect",t)}drawRoundedRect(...t){return E(D,"Graphics#drawRoundedRect has been renamed to Graphics#roundRect"),this._callContextMethod("roundRect",t)}drawStar(...t){return E(D,"Graphics#drawStar has been renamed to Graphics#star"),this._callContextMethod("star",t)}}const Jr=class ts extends Ie{constructor(...t){let e=t[0]??{};e instanceof Float32Array&&(E(D,"use new MeshGeometry({ positions, uvs, indices }) instead"),e={positions:e,uvs:t[1],indices:t[2]}),e={...ts.defaultOptions,...e};const r=e.positions||new Float32Array([0,0,1,0,1,1,0,1]),s=e.uvs||new Float32Array([0,0,1,0,1,1,0,1]),n=e.indices||new Uint32Array([0,1,2,0,2,3]),a=e.shrinkBuffersToFit,o=new at({data:r,label:"attribute-mesh-positions",shrinkToFit:a,usage:L.VERTEX|L.COPY_DST}),h=new at({data:s,label:"attribute-mesh-uvs",shrinkToFit:a,usage:L.VERTEX|L.COPY_DST}),l=new at({data:n,label:"index-mesh-buffer",shrinkToFit:a,usage:L.INDEX|L.COPY_DST});super({attributes:{aPosition:{buffer:o,format:"float32x2",stride:2*4,offset:0},aUV:{buffer:h,format:"float32x2",stride:2*4,offset:0}},indexBuffer:l,topology:e.topology}),this.batchMode="auto"}get positions(){return this.attributes.aPosition.buffer.data}set positions(t){this.attributes.aPosition.buffer.data=t}get uvs(){return this.attributes.aUV.buffer.data}set uvs(t){this.attributes.aUV.buffer.data=t}get indices(){return this.indexBuffer.data}set indices(t){this.indexBuffer.data=t}};Jr.defaultOptions={topology:"triangle-list",shrinkBuffersToFit:!1};let Le=Jr;const ln=["serif","sans-serif","monospace","cursive","fantasy","system-ui"];function jt(i){const t=typeof i.fontSize=="number"?`${i.fontSize}px`:i.fontSize;let e=i.fontFamily;Array.isArray(i.fontFamily)||(e=i.fontFamily.split(","));for(let r=e.length-1;r>=0;r--){let s=e[r].trim();!/([\"\'])[^\'\"]+\1/.test(s)&&!ln.includes(s)&&(s=`"${s}"`),e[r]=s}return`${i.fontStyle} ${i.fontVariant} ${i.fontWeight} ${t} ${e.join(",")}`}const pe={willReadFrequently:!0},Z=class M{static get experimentalLetterSpacingSupported(){let t=M._experimentalLetterSpacingSupported;if(t!==void 0){const e=q.get().getCanvasRenderingContext2D().prototype;t=M._experimentalLetterSpacingSupported="letterSpacing"in e||"textLetterSpacing"in e}return t}constructor(t,e,r,s,n,a,o,h,l){this.text=t,this.style=e,this.width=r,this.height=s,this.lines=n,this.lineWidths=a,this.lineHeight=o,this.maxLineWidth=h,this.fontProperties=l}static measureText(t=" ",e,r=M._canvas,s=e.wordWrap){var m;const n=`${t}:${e.styleKey}`;if(M._measurementCache[n])return M._measurementCache[n];const a=jt(e),o=M.measureFont(a);o.fontSize===0&&(o.fontSize=e.fontSize,o.ascent=e.fontSize);const h=M.__context;h.font=a;const c=(s?M._wordWrap(t,e,r):t).split(/(?:\r\n|\r|\n)/),u=new Array(c.length);let f=0;for(let y=0;y<c.length;y++){const b=M._measureText(c[y],e.letterSpacing,h);u[y]=b,f=Math.max(f,b)}const p=((m=e._stroke)==null?void 0:m.width)||0;let d=f+p;e.dropShadow&&(d+=e.dropShadow.distance);const x=e.lineHeight||o.fontSize+p;let g=Math.max(x,o.fontSize+p*2)+(c.length-1)*(x+e.leading);return e.dropShadow&&(g+=e.dropShadow.distance),new M(t,e,d,g,c,u,x+e.leading,f,o)}static _measureText(t,e,r){let s=!1;M.experimentalLetterSpacingSupported&&(M.experimentalLetterSpacing?(r.letterSpacing=`${e}px`,r.textLetterSpacing=`${e}px`,s=!0):(r.letterSpacing="0px",r.textLetterSpacing="0px"));let n=r.measureText(t).width;return n>0&&(s?n-=e:n+=(M.graphemeSegmenter(t).length-1)*e),n}static _wordWrap(t,e,r=M._canvas){const s=r.getContext("2d",pe);let n=0,a="",o="";const h=Object.create(null),{letterSpacing:l,whiteSpace:c}=e,u=M._collapseSpaces(c),f=M._collapseNewlines(c);let p=!u;const d=e.wordWrapWidth+l,x=M._tokenize(t);for(let g=0;g<x.length;g++){let _=x[g];if(M._isNewline(_)){if(!f){o+=M._addLine(a),p=!u,a="",n=0;continue}_=" "}if(u){const y=M.isBreakingSpace(_),b=M.isBreakingSpace(a[a.length-1]);if(y&&b)continue}const m=M._getFromCache(_,l,h,s);if(m>d)if(a!==""&&(o+=M._addLine(a),a="",n=0),M.canBreakWords(_,e.breakWords)){const y=M.wordWrapSplit(_);for(let b=0;b<y.length;b++){let P=y[b],k=P,T=1;for(;y[b+T];){const S=y[b+T];if(!M.canBreakChars(k,S,_,b,e.breakWords))P+=S;else break;k=S,T++}b+=T-1;const v=M._getFromCache(P,l,h,s);v+n>d&&(o+=M._addLine(a),p=!1,a="",n=0),a+=P,n+=v}}else{a.length>0&&(o+=M._addLine(a),a="",n=0);const y=g===x.length-1;o+=M._addLine(_,!y),p=!1,a="",n=0}else m+n>d&&(p=!1,o+=M._addLine(a),a="",n=0),(a.length>0||!M.isBreakingSpace(_)||p)&&(a+=_,n+=m)}return o+=M._addLine(a,!1),o}static _addLine(t,e=!0){return t=M._trimRight(t),t=e?`${t}
`:t,t}static _getFromCache(t,e,r,s){let n=r[t];return typeof n!="number"&&(n=M._measureText(t,e,s)+e,r[t]=n),n}static _collapseSpaces(t){return t==="normal"||t==="pre-line"}static _collapseNewlines(t){return t==="normal"}static _trimRight(t){if(typeof t!="string")return"";for(let e=t.length-1;e>=0;e--){const r=t[e];if(!M.isBreakingSpace(r))break;t=t.slice(0,-1)}return t}static _isNewline(t){return typeof t!="string"?!1:M._newlines.includes(t.charCodeAt(0))}static isBreakingSpace(t,e){return typeof t!="string"?!1:M._breakingSpaces.includes(t.charCodeAt(0))}static _tokenize(t){const e=[];let r="";if(typeof t!="string")return e;for(let s=0;s<t.length;s++){const n=t[s],a=t[s+1];if(M.isBreakingSpace(n,a)||M._isNewline(n)){r!==""&&(e.push(r),r=""),e.push(n);continue}r+=n}return r!==""&&e.push(r),e}static canBreakWords(t,e){return e}static canBreakChars(t,e,r,s,n){return!0}static wordWrapSplit(t){return M.graphemeSegmenter(t)}static measureFont(t){if(M._fonts[t])return M._fonts[t];const e=M._context;e.font=t;const r=e.measureText(M.METRICS_STRING+M.BASELINE_SYMBOL),s={ascent:r.actualBoundingBoxAscent,descent:r.actualBoundingBoxDescent,fontSize:r.actualBoundingBoxAscent+r.actualBoundingBoxDescent};return M._fonts[t]=s,s}static clearMetrics(t=""){t?delete M._fonts[t]:M._fonts={}}static get _canvas(){if(!M.__canvas){let t;try{const e=new OffscreenCanvas(0,0),r=e.getContext("2d",pe);if(r!=null&&r.measureText)return M.__canvas=e,e;t=q.get().createCanvas()}catch{t=q.get().createCanvas()}t.width=t.height=10,M.__canvas=t}return M.__canvas}static get _context(){return M.__context||(M.__context=M._canvas.getContext("2d",pe)),M.__context}};Z.METRICS_STRING="|q";Z.BASELINE_SYMBOL="M";Z.BASELINE_MULTIPLIER=1.4;Z.HEIGHT_MULTIPLIER=2;Z.graphemeSegmenter=(()=>{if(typeof(Intl==null?void 0:Intl.Segmenter)=="function"){const i=new Intl.Segmenter;return t=>[...i.segment(t)].map(e=>e.segment)}return i=>[...i]})();Z.experimentalLetterSpacing=!1;Z._fonts={};Z._newlines=[10,13];Z._breakingSpaces=[9,32,8192,8193,8194,8195,8196,8197,8198,8200,8201,8202,8287,12288];Z._measurementCache={};let rt=Z;const lr=["_fontFamily","_fontStyle","_fontSize","_fontVariant","_fontWeight","_breakWords","_align","_leading","_letterSpacing","_lineHeight","_textBaseline","_whiteSpace","_wordWrap","_wordWrapWidth","_padding","_cssOverrides","_trim"];function es(i){const t=[];let e=0;for(let r=0;r<lr.length;r++){const s=lr[r];t[e++]=i[s]}return e=rs(i._fill,t,e),e=un(i._stroke,t,e),t.join("-")}function rs(i,t,e){var r;return i&&(t[e++]=i.color,t[e++]=i.alpha,t[e++]=(r=i.fill)==null?void 0:r.uid),e}function un(i,t,e){return i&&(e=rs(i,t,e),t[e++]=i.width,t[e++]=i.alignment,t[e++]=i.cap,t[e++]=i.join,t[e++]=i.miterLimit),e}const He=class _t extends vt{constructor(t={}){super(),dn(t);const e={..._t.defaultTextStyle,...t};for(const r in e){const s=r;this[s]=e[r]}this.update()}get align(){return this._align}set align(t){this._align=t,this.update()}get breakWords(){return this._breakWords}set breakWords(t){this._breakWords=t,this.update()}get dropShadow(){return this._dropShadow}set dropShadow(t){t!==null&&typeof t=="object"?this._dropShadow={..._t.defaultDropShadow,...t}:this._dropShadow=t?{..._t.defaultDropShadow}:null,this.update()}get fontFamily(){return this._fontFamily}set fontFamily(t){this._fontFamily=t,this.update()}get fontSize(){return this._fontSize}set fontSize(t){typeof t=="string"?this._fontSize=parseInt(t,10):this._fontSize=t,this.update()}get fontStyle(){return this._fontStyle}set fontStyle(t){this._fontStyle=t,this.update()}get fontVariant(){return this._fontVariant}set fontVariant(t){this._fontVariant=t,this.update()}get fontWeight(){return this._fontWeight}set fontWeight(t){this._fontWeight=t,this.update()}get leading(){return this._leading}set leading(t){this._leading=t,this.update()}get letterSpacing(){return this._letterSpacing}set letterSpacing(t){this._letterSpacing=t,this.update()}get lineHeight(){return this._lineHeight}set lineHeight(t){this._lineHeight=t,this.update()}get padding(){return this._padding}set padding(t){this._padding=t,this.update()}get trim(){return this._trim}set trim(t){this._trim=t,this.update()}get textBaseline(){return this._textBaseline}set textBaseline(t){this._textBaseline=t,this.update()}get whiteSpace(){return this._whiteSpace}set whiteSpace(t){this._whiteSpace=t,this.update()}get wordWrap(){return this._wordWrap}set wordWrap(t){this._wordWrap=t,this.update()}get wordWrapWidth(){return this._wordWrapWidth}set wordWrapWidth(t){this._wordWrapWidth=t,this.update()}get fill(){return this._originalFill}set fill(t){t!==this._originalFill&&(this._originalFill=t,this._fill=it(t===0?"black":t,ft.defaultFillStyle),this.update())}get stroke(){return this._originalStroke}set stroke(t){t!==this._originalStroke&&(this._originalStroke=t,this._stroke=it(t,ft.defaultStrokeStyle),this.update())}_generateKey(){return this._styleKey=es(this),this._styleKey}update(){this._styleKey=null,this.emit("update",this)}reset(){const t=_t.defaultTextStyle;for(const e in t)this[e]=t[e]}get styleKey(){return this._styleKey||this._generateKey()}clone(){return new _t({align:this.align,breakWords:this.breakWords,dropShadow:this.dropShadow,fill:this._fill,fontFamily:this.fontFamily,fontSize:this.fontSize,fontStyle:this.fontStyle,fontVariant:this.fontVariant,fontWeight:this.fontWeight,leading:this.leading,letterSpacing:this.letterSpacing,lineHeight:this.lineHeight,padding:this.padding,stroke:this._stroke,textBaseline:this.textBaseline,whiteSpace:this.whiteSpace,wordWrap:this.wordWrap,wordWrapWidth:this.wordWrapWidth})}destroy(t=!1){var r,s,n,a;if(this.removeAllListeners(),typeof t=="boolean"?t:t==null?void 0:t.texture){const o=typeof t=="boolean"?t:t==null?void 0:t.textureSource;(r=this._fill)!=null&&r.texture&&this._fill.texture.destroy(o),(s=this._originalFill)!=null&&s.texture&&this._originalFill.texture.destroy(o),(n=this._stroke)!=null&&n.texture&&this._stroke.texture.destroy(o),(a=this._originalStroke)!=null&&a.texture&&this._originalStroke.texture.destroy(o)}this._fill=null,this._stroke=null,this.dropShadow=null,this._originalStroke=null,this._originalFill=null}};He.defaultDropShadow={alpha:1,angle:Math.PI/6,blur:0,color:"black",distance:5};He.defaultTextStyle={align:"left",breakWords:!1,dropShadow:null,fill:"black",fontFamily:"Arial",fontSize:26,fontStyle:"normal",fontVariant:"normal",fontWeight:"normal",leading:0,letterSpacing:0,lineHeight:0,padding:0,stroke:null,textBaseline:"alphabetic",trim:!1,whiteSpace:"pre",wordWrap:!1,wordWrapWidth:100};let Tt=He;function dn(i){const t=i;if(typeof t.dropShadow=="boolean"&&t.dropShadow){const e=Tt.defaultDropShadow;i.dropShadow={alpha:t.dropShadowAlpha??e.alpha,angle:t.dropShadowAngle??e.angle,blur:t.dropShadowBlur??e.blur,color:t.dropShadowColor??e.color,distance:t.dropShadowDistance??e.distance}}if(t.strokeThickness!==void 0){E(D,"strokeThickness is now a part of stroke");const e=t.stroke;i.stroke={color:e,width:t.strokeThickness}}if(Array.isArray(t.fill)){E(D,"gradient fill is now a fill pattern: `new FillGradient(...)`");const e=new De(0,0,0,i.fontSize*1.7),r=t.fill.map(s=>H.shared.setValue(s).toNumber());r.forEach((s,n)=>{const a=t.fillGradientStops[n]??n/r.length;e.addColorStop(a,s)}),i.fill={fill:e}}}class fn{constructor(t){this._canvasPool=Object.create(null),this.canvasOptions=t||{},this.enableFullScreen=!1}_createCanvasAndContext(t,e){const r=q.get().createCanvas();r.width=t,r.height=e;const s=r.getContext("2d");return{canvas:r,context:s}}getOptimalCanvasAndContext(t,e,r=1){t=Math.ceil(t*r-1e-6),e=Math.ceil(e*r-1e-6),t=bt(t),e=bt(e);const s=(t<<17)+(e<<1);this._canvasPool[s]||(this._canvasPool[s]=[]);let n=this._canvasPool[s].pop();return n||(n=this._createCanvasAndContext(t,e)),n}returnCanvasAndContext(t){const{width:e,height:r}=t.canvas,s=(e<<17)+(r<<1);this._canvasPool[s].push(t)}clear(){this._canvasPool={}}}const pt=new fn;function Yt(i,t){if(i.texture===O.WHITE&&!i.fill)return H.shared.setValue(i.color).toHex();if(i.fill){if(i.fill instanceof qr){const e=i.fill,r=t.createPattern(e.texture.source.resource,"repeat"),s=e.transform.copyTo(V.shared);return s.scale(e.texture.frame.width,e.texture.frame.height),r.setTransform(s),r}else if(i.fill instanceof De){const e=i.fill;if(e.type==="linear"){const r=t.createLinearGradient(e.x0,e.y0,e.x1,e.y1);return e.gradientStops.forEach(s=>{r.addColorStop(s.offset,H.shared.setValue(s.color).toHex())}),r}}}else{const e=t.createPattern(i.texture.source.resource,"repeat"),r=i.matrix.copyTo(V.shared);return r.scale(i.texture.frame.width,i.texture.frame.height),e.setTransform(r),e}return ot("FillStyle not recognised",i),"red"}class ss extends vt{constructor(){super(...arguments),this.chars=Object.create(null),this.lineHeight=0,this.fontFamily="",this.fontMetrics={fontSize:0,ascent:0,descent:0},this.baseLineOffset=0,this.distanceField={type:"none",range:0},this.pages=[],this.baseMeasurementFontSize=100,this.baseRenderedFontSize=100}get font(){return E(D,"BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead."),this.fontFamily}get pageTextures(){return E(D,"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),this.pages}get size(){return E(D,"BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead."),this.fontMetrics.fontSize}get distanceFieldRange(){return E(D,"BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead."),this.distanceField.range}get distanceFieldType(){return E(D,"BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead."),this.distanceField.type}destroy(t=!1){this.emit("destroy",this),this.removeAllListeners();for(const e in this.chars)this.chars[e].texture.destroy();this.chars=null,t&&(this.pages.forEach(e=>e.texture.destroy(!0)),this.pages=null)}}function is(i){if(i==="")return[];typeof i=="string"&&(i=[i]);const t=[];for(let e=0,r=i.length;e<r;e++){const s=i[e];if(Array.isArray(s)){if(s.length!==2)throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${s.length}.`);if(s[0].length===0||s[1].length===0)throw new Error("[BitmapFont]: Invalid character delimiter.");const n=s[0].charCodeAt(0),a=s[1].charCodeAt(0);if(a<n)throw new Error("[BitmapFont]: Invalid character range.");for(let o=n,h=a;o<=h;o++)t.push(String.fromCharCode(o))}else t.push(...Array.from(s))}if(t.length===0)throw new Error("[BitmapFont]: Empty set when resolving characters.");return t}class ur extends ss{constructor(t){super(),this.resolution=1,this.pages=[],this._padding=4,this._measureCache=Object.create(null),this._currentChars=[],this._currentX=0,this._currentY=0,this._currentPageIndex=-1,this._skipKerning=!1;const e=t,r=e.style.clone();e.overrideFill&&(r._fill.color=16777215,r._fill.alpha=1,r._fill.texture=O.WHITE,r._fill.fill=null);const s=r.fontSize;r.fontSize=this.baseMeasurementFontSize;const n=jt(r);e.overrideSize?r._stroke&&(r._stroke.width*=this.baseRenderedFontSize/s):r.fontSize=this.baseRenderedFontSize=s,this._style=r,this._skipKerning=e.skipKerning??!1,this.resolution=e.resolution??1,this._padding=e.padding??4,this.fontMetrics=rt.measureFont(n),this.lineHeight=r.lineHeight||this.fontMetrics.fontSize||r.fontSize}ensureCharacters(t){var x,g;const e=is(t).filter(_=>!this._currentChars.includes(_)).filter((_,m,y)=>y.indexOf(_)===m);if(!e.length)return;this._currentChars=[...this._currentChars,...e];let r;this._currentPageIndex===-1?r=this._nextPage():r=this.pages[this._currentPageIndex];let{canvas:s,context:n}=r.canvasAndContext,a=r.texture.source;const o=this._style;let h=this._currentX,l=this._currentY;const c=this.baseRenderedFontSize/this.baseMeasurementFontSize,u=this._padding*c,f=o.fontStyle==="italic"?2:1;let p=0,d=!1;for(let _=0;_<e.length;_++){const m=e[_],y=rt.measureText(m,o,s,!1);y.lineHeight=y.height;const b=f*y.width*c,P=y.height*c,k=b+u*2,T=P+u*2;if(d=!1,m!==`
`&&m!=="\r"&&m!=="	"&&m!==" "&&(d=!0,p=Math.ceil(Math.max(T,p))),h+k>512&&(l+=p,p=T,h=0,l+p>512)){a.update();const S=this._nextPage();s=S.canvasAndContext.canvas,n=S.canvasAndContext.context,a=S.texture.source,l=0}const v=b/c-(((x=o.dropShadow)==null?void 0:x.distance)??0)-(((g=o._stroke)==null?void 0:g.width)??0);if(this.chars[m]={id:m.codePointAt(0),xOffset:-this._padding,yOffset:-this._padding,xAdvance:v,kerning:{}},d){this._drawGlyph(n,y,h+u,l+u,c,o);const S=a.width*c,w=a.height*c,G=new Q(h/S*a.width,l/w*a.height,k/S*a.width,T/w*a.height);this.chars[m].texture=new O({source:a,frame:G}),h+=Math.ceil(k)}}a.update(),this._currentX=h,this._currentY=l,this._skipKerning&&this._applyKerning(e,n)}get pageTextures(){return E(D,"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),this.pages}_applyKerning(t,e){const r=this._measureCache;for(let s=0;s<t.length;s++){const n=t[s];for(let a=0;a<this._currentChars.length;a++){const o=this._currentChars[a];let h=r[n];h||(h=r[n]=e.measureText(n).width);let l=r[o];l||(l=r[o]=e.measureText(o).width);let c=e.measureText(n+o).width,u=c-(h+l);u&&(this.chars[n].kerning[o]=u),c=e.measureText(n+o).width,u=c-(h+l),u&&(this.chars[o].kerning[n]=u)}}}_nextPage(){this._currentPageIndex++;const t=this.resolution,e=pt.getOptimalCanvasAndContext(512,512,t);this._setupContext(e.context,this._style,t);const r=t*(this.baseRenderedFontSize/this.baseMeasurementFontSize),s=new O({source:new Br({resource:e.canvas,resolution:r,alphaMode:"premultiply-alpha-on-upload"})}),n={canvasAndContext:e,texture:s};return this.pages[this._currentPageIndex]=n,n}_setupContext(t,e,r){e.fontSize=this.baseRenderedFontSize,t.scale(r,r),t.font=jt(e),e.fontSize=this.baseMeasurementFontSize,t.textBaseline=e.textBaseline;const s=e._stroke,n=(s==null?void 0:s.width)??0;if(s&&(t.lineWidth=n,t.lineJoin=s.join,t.miterLimit=s.miterLimit,t.strokeStyle=Yt(s,t)),e._fill&&(t.fillStyle=Yt(e._fill,t)),e.dropShadow){const a=e.dropShadow,o=H.shared.setValue(a.color).toArray(),h=a.blur*r,l=a.distance*r;t.shadowColor=`rgba(${o[0]*255},${o[1]*255},${o[2]*255},${a.alpha})`,t.shadowBlur=h,t.shadowOffsetX=Math.cos(a.angle)*l,t.shadowOffsetY=Math.sin(a.angle)*l}else t.shadowColor="black",t.shadowBlur=0,t.shadowOffsetX=0,t.shadowOffsetY=0}_drawGlyph(t,e,r,s,n,a){const o=e.text,h=e.fontProperties,l=a._stroke,c=((l==null?void 0:l.width)??0)*n,u=r+c/2,f=s-c/2,p=h.descent*n,d=e.lineHeight*n;a.stroke&&c&&t.strokeText(o,u,f+d-p),a._fill&&t.fillText(o,u,f+d-p)}destroy(){super.destroy();for(let t=0;t<this.pages.length;t++){const{canvasAndContext:e,texture:r}=this.pages[t];pt.returnCanvasAndContext(e),r.destroy(!0)}this.pages=null}}function ns(i,t,e){const r={width:0,height:0,offsetY:0,scale:t.fontSize/e.baseMeasurementFontSize,lines:[{width:0,charPositions:[],spaceWidth:0,spacesIndex:[],chars:[]}]};r.offsetY=e.baseLineOffset;let s=r.lines[0],n=null,a=!0;const o={spaceWord:!1,width:0,start:0,index:0,positions:[],chars:[]},h=p=>{const d=s.width;for(let x=0;x<o.index;x++){const g=p.positions[x];s.chars.push(p.chars[x]),s.charPositions.push(g+d)}s.width+=p.width,a=!1,o.width=0,o.index=0,o.chars.length=0},l=()=>{let p=s.chars.length-1,d=s.chars[p];for(;d===" ";)s.width-=e.chars[d].xAdvance,d=s.chars[--p];r.width=Math.max(r.width,s.width),s={width:0,charPositions:[],chars:[],spaceWidth:0,spacesIndex:[]},a=!0,r.lines.push(s),r.height+=e.lineHeight},c=e.baseMeasurementFontSize/t.fontSize,u=t.letterSpacing*c,f=t.wordWrapWidth*c;for(let p=0;p<i.length+1;p++){let d;const x=p===i.length;x||(d=i[p]);const g=e.chars[d]||e.chars[" "];if(/(?:\s)/.test(d)||d==="\r"||d===`
`||x){if(!a&&t.wordWrap&&s.width+o.width-u>f?(l(),h(o),x||s.charPositions.push(0)):(o.start=s.width,h(o),x||s.charPositions.push(0)),d==="\r"||d===`
`)s.width!==0&&l();else if(!x){const b=g.xAdvance+(g.kerning[n]||0)+u;s.width+=b,s.spaceWidth=b,s.spacesIndex.push(s.charPositions.length),s.chars.push(d)}}else{const y=g.kerning[n]||0,b=g.xAdvance+y+u;o.positions[o.index++]=o.width+y,o.chars.push(d),o.width+=b}n=d}return l(),t.align==="center"?pn(r):t.align==="right"?gn(r):t.align==="justify"&&mn(r),r}function pn(i){for(let t=0;t<i.lines.length;t++){const e=i.lines[t],r=i.width/2-e.width/2;for(let s=0;s<e.charPositions.length;s++)e.charPositions[s]+=r}}function gn(i){for(let t=0;t<i.lines.length;t++){const e=i.lines[t],r=i.width-e.width;for(let s=0;s<e.charPositions.length;s++)e.charPositions[s]+=r}}function mn(i){const t=i.width;for(let e=0;e<i.lines.length;e++){const r=i.lines[e];let s=0,n=r.spacesIndex[s++],a=0;const o=r.spacesIndex.length,l=(t-r.width)/o;for(let c=0;c<r.charPositions.length;c++)c===n&&(n=r.spacesIndex[s++],a+=l),r.charPositions[c]+=a}}class xn{constructor(){this.ALPHA=[["a","z"],["A","Z"]," "],this.NUMERIC=[["0","9"]],this.ALPHANUMERIC=[["a","z"],["A","Z"],["0","9"]," "],this.ASCII=[[" ","~"]],this.defaultOptions={chars:this.ALPHANUMERIC,resolution:1,padding:4,skipKerning:!1}}getFont(t,e){var a;let r=`${e.fontFamily}-bitmap`,s=!0;if(e._fill.fill&&(r+=e._fill.fill.uid,s=!1),!X.has(r)){const o=new ur({style:e,overrideFill:s,overrideSize:!0,...this.defaultOptions});o.once("destroy",()=>X.remove(r)),X.set(r,o)}const n=X.get(r);return(a=n.ensureCharacters)==null||a.call(n,t),n}getLayout(t,e){const r=this.getFont(t,e);return ns([...t],e,r)}measureText(t,e){return this.getLayout(t,e)}install(...t){var l,c,u,f;let e=t[0];typeof e=="string"&&(e={name:e,style:t[1],chars:(l=t[2])==null?void 0:l.chars,resolution:(c=t[2])==null?void 0:c.resolution,padding:(u=t[2])==null?void 0:u.padding,skipKerning:(f=t[2])==null?void 0:f.skipKerning},E(D,"BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})"));const r=e==null?void 0:e.name;if(!r)throw new Error("[BitmapFontManager] Property `name` is required.");e={...this.defaultOptions,...e};const s=e.style,n=s instanceof Tt?s:new Tt(s),a=n._fill.fill!==null&&n._fill.fill!==void 0,o=new ur({style:n,overrideFill:a,skipKerning:e.skipKerning,padding:e.padding,resolution:e.resolution,overrideSize:!1}),h=is(e.chars);return o.ensureCharacters(h.join("")),X.set(`${r}-bitmap`,o),o.once("destroy",()=>X.remove(`${r}-bitmap`)),o}uninstall(t){const e=`${t}-bitmap`,r=X.get(e);r&&(X.remove(e),r.destroy())}}const ke=new xn;function _n(i){const t=i._stroke,e=i._fill,s=[`div { ${[`color: ${H.shared.setValue(e.color).toHex()}`,`font-size: ${i.fontSize}px`,`font-family: ${i.fontFamily}`,`font-weight: ${i.fontWeight}`,`font-style: ${i.fontStyle}`,`font-variant: ${i.fontVariant}`,`letter-spacing: ${i.letterSpacing}px`,`text-align: ${i.align}`,`padding: ${i.padding}px`,`white-space: ${i.whiteSpace==="pre"&&i.wordWrap?"pre-wrap":i.whiteSpace}`,...i.lineHeight?[`line-height: ${i.lineHeight}px`]:[],...i.wordWrap?[`word-wrap: ${i.breakWords?"break-all":"break-word"}`,`max-width: ${i.wordWrapWidth}px`]:[],...t?[os(t)]:[],...i.dropShadow?[as(i.dropShadow)]:[],...i.cssOverrides].join(";")} }`];return yn(i.tagStyles,s),s.join(" ")}function as(i){const t=H.shared.setValue(i.color).setAlpha(i.alpha).toHexa(),e=Math.round(Math.cos(i.angle)*i.distance),r=Math.round(Math.sin(i.angle)*i.distance),s=`${e}px ${r}px`;return i.blur>0?`text-shadow: ${s} ${i.blur}px ${t}`:`text-shadow: ${s} ${t}`}function os(i){return[`-webkit-text-stroke-width: ${i.width}px`,`-webkit-text-stroke-color: ${H.shared.setValue(i.color).toHex()}`,`text-stroke-width: ${i.width}px`,`text-stroke-color: ${H.shared.setValue(i.color).toHex()}`,"paint-order: stroke"].join(";")}const dr={fontSize:"font-size: {{VALUE}}px",fontFamily:"font-family: {{VALUE}}",fontWeight:"font-weight: {{VALUE}}",fontStyle:"font-style: {{VALUE}}",fontVariant:"font-variant: {{VALUE}}",letterSpacing:"letter-spacing: {{VALUE}}px",align:"text-align: {{VALUE}}",padding:"padding: {{VALUE}}px",whiteSpace:"white-space: {{VALUE}}",lineHeight:"line-height: {{VALUE}}px",wordWrapWidth:"max-width: {{VALUE}}px"},fr={fill:i=>`color: ${H.shared.setValue(i).toHex()}`,breakWords:i=>`word-wrap: ${i?"break-all":"break-word"}`,stroke:os,dropShadow:as};function yn(i,t){for(const e in i){const r=i[e],s=[];for(const n in r)fr[n]?s.push(fr[n](r[n])):dr[n]&&s.push(dr[n].replace("{{VALUE}}",r[n]));t.push(`${e} { ${s.join(";")} }`)}}class Oe extends Tt{constructor(t={}){super(t),this._cssOverrides=[],this.cssOverrides??(this.cssOverrides=t.cssOverrides),this.tagStyles=t.tagStyles??{}}set cssOverrides(t){this._cssOverrides=t instanceof Array?t:[t],this.update()}get cssOverrides(){return this._cssOverrides}_generateKey(){return this._styleKey=es(this)+this._cssOverrides.join("-"),this._styleKey}update(){this._cssStyle=null,super.update()}clone(){return new Oe({align:this.align,breakWords:this.breakWords,dropShadow:this.dropShadow,fill:this._fill,fontFamily:this.fontFamily,fontSize:this.fontSize,fontStyle:this.fontStyle,fontVariant:this.fontVariant,fontWeight:this.fontWeight,letterSpacing:this.letterSpacing,lineHeight:this.lineHeight,padding:this.padding,stroke:this._stroke,whiteSpace:this.whiteSpace,wordWrap:this.wordWrap,wordWrapWidth:this.wordWrapWidth,cssOverrides:this.cssOverrides})}get cssStyle(){return this._cssStyle||(this._cssStyle=_n(this)),this._cssStyle}addOverride(...t){const e=t.filter(r=>!this.cssOverrides.includes(r));e.length>0&&(this.cssOverrides.push(...e),this.update())}removeOverride(...t){const e=t.filter(r=>this.cssOverrides.includes(r));e.length>0&&(this.cssOverrides=this.cssOverrides.filter(r=>!e.includes(r)),this.update())}set fill(t){typeof t!="string"&&typeof t!="number"&&ot("[HTMLTextStyle] only color fill is not supported by HTMLText"),super.fill=t}set stroke(t){t&&typeof t!="string"&&typeof t!="number"&&ot("[HTMLTextStyle] only color stroke is not supported by HTMLText"),super.stroke=t}}const pr="http://www.w3.org/2000/svg",gr="http://www.w3.org/1999/xhtml";class hs{constructor(){this.svgRoot=document.createElementNS(pr,"svg"),this.foreignObject=document.createElementNS(pr,"foreignObject"),this.domElement=document.createElementNS(gr,"div"),this.styleElement=document.createElementNS(gr,"style"),this.image=new Image;const{foreignObject:t,svgRoot:e,styleElement:r,domElement:s}=this;t.setAttribute("width","10000"),t.setAttribute("height","10000"),t.style.overflow="hidden",e.appendChild(t),t.appendChild(r),t.appendChild(s)}}let mr;function bn(i,t,e,r){r=r||mr||(mr=new hs);const{domElement:s,styleElement:n,svgRoot:a}=r;s.innerHTML=`<style>${t.cssStyle}</style><div>${i}</div>`,s.setAttribute("style","transform-origin: top left; display: inline-block"),e&&(n.textContent=e),document.body.appendChild(a);const o=s.getBoundingClientRect();a.remove();const h=rt.measureFont(t.fontStyle).descent;return{width:o.width,height:o.height+h}}function xr(i,t,e){if(i)for(const r in i){const s=r.toLocaleLowerCase(),n=t[s];if(n){let a=i[r];r==="header"&&(a=a.replace(/@in\s+[^;]+;\s*/g,"").replace(/@out\s+[^;]+;\s*/g,"")),e&&n.push(`//----${e}----//`),n.push(a)}else ot(`${r} placement hook does not exist in shader`)}}const Sn=/\{\{(.*?)\}\}/g;function _r(i){var r;const t={};return(((r=i.match(Sn))==null?void 0:r.map(s=>s.replace(/[{()}]/g,"")))??[]).forEach(s=>{t[s]=[]}),t}function yr(i,t){let e;const r=/@in\s+([^;]+);/g;for(;(e=r.exec(i))!==null;)t.push(e[1])}function br(i,t,e=!1){const r=[];yr(t,r),i.forEach(o=>{o.header&&yr(o.header,r)});const s=r;e&&s.sort();const n=s.map((o,h)=>`       @location(${h}) ${o},`).join(`
`);let a=t.replace(/@in\s+[^;]+;\s*/g,"");return a=a.replace("{{in}}",`
${n}
`),a}function Sr(i,t){let e;const r=/@out\s+([^;]+);/g;for(;(e=r.exec(i))!==null;)t.push(e[1])}function wn(i){const e=/\b(\w+)\s*:/g.exec(i);return e?e[1]:""}function Tn(i){const t=/@.*?\s+/g;return i.replace(t,"")}function vn(i,t){const e=[];Sr(t,e),i.forEach(h=>{h.header&&Sr(h.header,e)});let r=0;const s=e.sort().map(h=>h.indexOf("builtin")>-1?h:`@location(${r++}) ${h}`).join(`,
`),n=e.sort().map(h=>`       var ${Tn(h)};`).join(`
`),a=`return VSOutput(
                ${e.sort().map(h=>` ${wn(h)}`).join(`,
`)});`;let o=t.replace(/@out\s+[^;]+;\s*/g,"");return o=o.replace("{{struct}}",`
${s}
`),o=o.replace("{{start}}",`
${n}
`),o=o.replace("{{return}}",`
${a}
`),o}function wr(i,t){let e=i;for(const r in t){const s=t[r];s.join(`
`).length?e=e.replace(`{{${r}}}`,`//-----${r} START-----//
${s.join(`
`)}
//----${r} FINISH----//`):e=e.replace(`{{${r}}}`,"")}return e}const nt=Object.create(null),ge=new Map;let Pn=0;function Cn({template:i,bits:t}){const e=cs(i,t);if(nt[e])return nt[e];const{vertex:r,fragment:s}=kn(i,t);return nt[e]=ls(r,s,t),nt[e]}function Mn({template:i,bits:t}){const e=cs(i,t);return nt[e]||(nt[e]=ls(i.vertex,i.fragment,t)),nt[e]}function kn(i,t){const e=t.map(a=>a.vertex).filter(a=>!!a),r=t.map(a=>a.fragment).filter(a=>!!a);let s=br(e,i.vertex,!0);s=vn(e,s);const n=br(r,i.fragment,!0);return{vertex:s,fragment:n}}function cs(i,t){return t.map(e=>(ge.has(e)||ge.set(e,Pn++),ge.get(e))).sort((e,r)=>e-r).join("-")+i.vertex+i.fragment}function ls(i,t,e){const r=_r(i),s=_r(t);return e.forEach(n=>{xr(n.vertex,r,n.name),xr(n.fragment,s,n.name)}),{vertex:wr(i,r),fragment:wr(t,s)}}const Bn=`
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}
        
        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);
       
        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`,An=`
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;
   
    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {
        
        {{start}}

        var outColor:vec4<f32>;
      
        {{main}}
        
        return outColor * vColor;
      };
`,Fn=`
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;
        
        {{start}}
        
        vColor = vec4(1.);
        
        {{main}}
        
        vUV = uv;
        
        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`,Rn=`
   
    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {
        
        {{start}}

        vec4 outColor;
      
        {{main}}
        
        finalColor = outColor * vColor;
    }
`,In={name:"global-uniforms-bit",vertex:{header:`
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `}},zn={name:"global-uniforms-bit",vertex:{header:`
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `}};function us({bits:i,name:t}){const e=Cn({template:{fragment:An,vertex:Bn},bits:[In,...i]});return Xt.from({name:t,vertex:{source:e.vertex,entryPoint:"main"},fragment:{source:e.fragment,entryPoint:"main"}})}function ds({bits:i,name:t}){return new Rr({name:t,...Mn({template:{vertex:Fn,fragment:Rn},bits:[zn,...i]})})}const Gn={name:"color-bit",vertex:{header:`
            @in aColor: vec4<f32>;
        `,main:`
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `}},Un={name:"color-bit",vertex:{header:`
            in vec4 aColor;
        `,main:`
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `}},me={};function En(i){const t=[];if(i===1)t.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"),t.push("@group(1) @binding(1) var textureSampler1: sampler;");else{let e=0;for(let r=0;r<i;r++)t.push(`@group(1) @binding(${e++}) var textureSource${r+1}: texture_2d<f32>;`),t.push(`@group(1) @binding(${e++}) var textureSampler${r+1}: sampler;`)}return t.join(`
`)}function Dn(i){const t=[];if(i===1)t.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");else{t.push("switch vTextureId {");for(let e=0;e<i;e++)e===i-1?t.push("  default:{"):t.push(`  case ${e}:{`),t.push(`      outColor = textureSampleGrad(textureSource${e+1}, textureSampler${e+1}, vUV, uvDx, uvDy);`),t.push("      break;}");t.push("}")}return t.join(`
`)}function Wn(i){return me[i]||(me[i]={name:"texture-batch-bit",vertex:{header:`
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,main:`
                vTextureId = aTextureIdAndRound.y;
            `,end:`
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `},fragment:{header:`
                @in @interpolate(flat) vTextureId: u32;
    
                ${En(et)}
            `,main:`
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);
    
                ${Dn(et)}
            `}}),me[i]}const xe={};function Ln(i){const t=[];for(let e=0;e<i;e++)e>0&&t.push("else"),e<i-1&&t.push(`if(vTextureId < ${e}.5)`),t.push("{"),t.push(`	outColor = texture(uTextures[${e}], vUV);`),t.push("}");return t.join(`
`)}function Hn(i){return xe[i]||(xe[i]={name:"texture-batch-bit",vertex:{header:`
                in vec2 aTextureIdAndRound;
                out float vTextureId;
              
            `,main:`
                vTextureId = aTextureIdAndRound.y;
            `,end:`
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `},fragment:{header:`
                in float vTextureId;
    
                uniform sampler2D uTextures[${i}];
              
            `,main:`
    
                ${Ln(et)}
            `}}),xe[i]}const fs={name:"round-pixels-bit",vertex:{header:`
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> 
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `}},ps={name:"round-pixels-bit",vertex:{header:`   
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {       
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `}},gs=new Int32Array(et);for(let i=0;i<et;i++)gs[i]=i;const On=new mt({uTextures:{value:gs,type:"i32",size:et}},{isStatic:!0}),Vt={name:"local-uniform-bit",vertex:{header:`

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,main:`
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,end:`
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `}};({...Vt,vertex:{...Vt.vertex,header:Vt.vertex.header.replace("group(1)","group(2)")}});const $n={name:"local-uniform-bit",vertex:{header:`

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,main:`
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `,end:`
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `}};class ms{constructor(){this.vertexSize=4,this.indexSize=6,this.location=0,this.batcher=null,this.batch=null,this.roundPixels=0}get blendMode(){return this.renderable.groupBlendMode}packAttributes(t,e,r,s){const n=this.renderable,a=this.texture,o=n.groupTransform,h=o.a,l=o.b,c=o.c,u=o.d,f=o.tx,p=o.ty,d=this.bounds,x=d.maxX,g=d.minX,_=d.maxY,m=d.minY,y=a.uvs,b=n.groupColorAlpha,P=s<<16|this.roundPixels&65535;t[r+0]=h*g+c*m+f,t[r+1]=u*m+l*g+p,t[r+2]=y.x0,t[r+3]=y.y0,e[r+4]=b,e[r+5]=P,t[r+6]=h*x+c*m+f,t[r+7]=u*m+l*x+p,t[r+8]=y.x1,t[r+9]=y.y1,e[r+10]=b,e[r+11]=P,t[r+12]=h*x+c*_+f,t[r+13]=u*_+l*x+p,t[r+14]=y.x2,t[r+15]=y.y2,e[r+16]=b,e[r+17]=P,t[r+18]=h*g+c*_+f,t[r+19]=u*_+l*g+p,t[r+20]=y.x3,t[r+21]=y.y3,e[r+22]=b,e[r+23]=P}packIndex(t,e,r){t[e]=r+0,t[e+1]=r+1,t[e+2]=r+2,t[e+3]=r+0,t[e+4]=r+2,t[e+5]=r+3}reset(){this.renderable=null,this.texture=null,this.batcher=null,this.batch=null,this.bounds=null}}function $e(i,t,e){const r=(i>>24&255)/255;t[e++]=(i&255)/255*r,t[e++]=(i>>8&255)/255*r,t[e++]=(i>>16&255)/255*r,t[e++]=r}class xs{constructor(t,e){this.state=Ur.for2d(),this._graphicsBatchesHash=Object.create(null),this.renderer=t,this._adaptor=e,this._adaptor.init()}validateRenderable(t){const e=t.context,r=!!this._graphicsBatchesHash[t.uid],s=this.renderer.graphicsContext.updateGpuContext(e);return!!(s.isBatchable||r!==s.isBatchable)}addRenderable(t,e){const r=this.renderer.graphicsContext.updateGpuContext(t.context);t._didGraphicsUpdate&&(t._didGraphicsUpdate=!1,this._rebuild(t)),r.isBatchable?this._addToBatcher(t,e):(this.renderer.renderPipes.batch.break(e),e.add(t))}updateRenderable(t){const e=this._graphicsBatchesHash[t.uid];if(e)for(let r=0;r<e.length;r++){const s=e[r];s.batcher.updateElement(s)}}destroyRenderable(t){this._graphicsBatchesHash[t.uid]&&this._removeBatchForRenderable(t.uid)}execute(t){if(!t.isRenderable)return;const e=this.renderer,r=t.context;if(!e.graphicsContext.getGpuContext(r).batches.length)return;const n=r.customShader||this._adaptor.shader;this.state.blendMode=t.groupBlendMode;const a=n.resources.localUniforms.uniforms;a.uTransformMatrix=t.groupTransform,a.uRound=e._roundPixels|t._roundPixels,$e(t.groupColorAlpha,a.uColor,0),this._adaptor.execute(this,t)}_rebuild(t){const e=!!this._graphicsBatchesHash[t.uid],r=this.renderer.graphicsContext.updateGpuContext(t.context);e&&this._removeBatchForRenderable(t.uid),r.isBatchable&&this._initBatchesForRenderable(t),t.batched=r.isBatchable}_addToBatcher(t,e){const r=this.renderer.renderPipes.batch,s=this._getBatchesForRenderable(t);for(let n=0;n<s.length;n++){const a=s[n];r.addToBatch(a,e)}}_getBatchesForRenderable(t){return this._graphicsBatchesHash[t.uid]||this._initBatchesForRenderable(t)}_initBatchesForRenderable(t){const e=t.context,r=this.renderer.graphicsContext.getGpuContext(e),s=this.renderer._roundPixels|t._roundPixels,n=r.batches.map(a=>{const o=W.get(ze);return a.copyTo(o),o.renderable=t,o.roundPixels=s,o});return this._graphicsBatchesHash[t.uid]=n,t.on("destroyed",()=>{this.destroyRenderable(t)}),n}_removeBatchForRenderable(t){this._graphicsBatchesHash[t].forEach(e=>{W.return(e)}),this._graphicsBatchesHash[t]=null}destroy(){this.renderer=null,this._adaptor.destroy(),this._adaptor=null,this.state=null;for(const t in this._graphicsBatchesHash)this._removeBatchForRenderable(t);this._graphicsBatchesHash=null}}xs.extension={type:[R.WebGLPipes,R.WebGPUPipes,R.CanvasPipes],name:"graphics"};const _s=class ys extends Le{constructor(...t){super({});let e=t[0]??{};typeof e=="number"&&(E(D,"PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead"),e={width:e,height:t[1],verticesX:t[2],verticesY:t[3]}),this.build(e)}build(t){t={...ys.defaultOptions,...t},this.verticesX=this.verticesX??t.verticesX,this.verticesY=this.verticesY??t.verticesY,this.width=this.width??t.width,this.height=this.height??t.height;const e=this.verticesX*this.verticesY,r=[],s=[],n=[],a=this.verticesX-1,o=this.verticesY-1,h=this.width/a,l=this.height/o;for(let u=0;u<e;u++){const f=u%this.verticesX,p=u/this.verticesX|0;r.push(f*h,p*l),s.push(f/a,p/o)}const c=a*o;for(let u=0;u<c;u++){const f=u%a,p=u/a|0,d=p*this.verticesX+f,x=p*this.verticesX+f+1,g=(p+1)*this.verticesX+f,_=(p+1)*this.verticesX+f+1;n.push(d,x,g,x,_,g)}this.buffers[0].data=new Float32Array(r),this.buffers[1].data=new Float32Array(s),this.indexBuffer.data=new Uint32Array(n),this.buffers[0].update(),this.buffers[1].update(),this.indexBuffer.update()}};_s.defaultOptions={width:100,height:100,verticesX:10,verticesY:10};let Vn=_s;class Ve{constructor(){this.batcher=null,this.batch=null,this.roundPixels=0,this._uvUpdateId=-1,this._textureMatrixUpdateId=-1}get blendMode(){return this.mesh.groupBlendMode}reset(){this.mesh=null,this.texture=null,this.batcher=null,this.batch=null}packIndex(t,e,r){const s=this.geometry.indices;for(let n=0;n<s.length;n++)t[e++]=s[n]+r}packAttributes(t,e,r,s){const n=this.mesh,a=this.geometry,o=n.groupTransform,h=s<<16|this.roundPixels&65535,l=o.a,c=o.b,u=o.c,f=o.d,p=o.tx,d=o.ty,x=a.positions,g=a.getBuffer("aUV"),_=g.data;let m=_;const y=this.texture.textureMatrix;y.isSimple||(m=this._transformedUvs,(this._textureMatrixUpdateId!==y._updateID||this._uvUpdateId!==g._updateID)&&((!m||m.length<_.length)&&(m=this._transformedUvs=new Float32Array(_.length)),this._textureMatrixUpdateId=y._updateID,this._uvUpdateId=g._updateID,y.multiplyUvs(_,m)));const b=n.groupColorAlpha;for(let P=0;P<x.length;P+=2){const k=x[P],T=x[P+1];t[r]=l*k+u*T+p,t[r+1]=c*k+f*T+d,t[r+2]=m[P],t[r+3]=m[P+1],e[r+4]=b,e[r+5]=h,r+=6}}get vertexSize(){return this.geometry.positions.length/2}get indexSize(){return this.geometry.indices.length}}class bs{constructor(t,e){this.localUniforms=new mt({uTransformMatrix:{value:new V,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}}),this.localUniformsBindGroup=new yt({0:this.localUniforms}),this._meshDataHash=Object.create(null),this._gpuBatchableMeshHash=Object.create(null),this.renderer=t,this._adaptor=e,this._adaptor.init()}validateRenderable(t){const e=this._getMeshData(t),r=e.batched,s=t.batched;if(e.batched=s,r!==s)return!0;if(s){const n=t._geometry;if(n.indices.length!==e.indexSize||n.positions.length!==e.vertexSize)return e.indexSize=n.indices.length,e.vertexSize=n.positions.length,!0;const a=this._getBatchableMesh(t),o=t.texture;if(a.texture._source!==o._source&&a.texture._source!==o._source)return!a.batcher.checkAndUpdateTexture(a,o)}return!1}addRenderable(t,e){const r=this.renderer.renderPipes.batch,{batched:s}=this._getMeshData(t);if(s){const n=this._getBatchableMesh(t);n.texture=t._texture,n.geometry=t._geometry,r.addToBatch(n)}else r.break(e),e.add({renderPipeId:"mesh",mesh:t})}updateRenderable(t){if(t.batched){const e=this._gpuBatchableMeshHash[t.uid];e.texture=t._texture,e.geometry=t._geometry,e.batcher.updateElement(e)}}destroyRenderable(t){this._meshDataHash[t.uid]=null;const e=this._gpuBatchableMeshHash[t.uid];e&&(W.return(e),this._gpuBatchableMeshHash[t.uid]=null)}execute({mesh:t}){if(!t.isRenderable)return;t.state.blendMode=t.groupBlendMode;const e=this.localUniforms;e.uniforms.uTransformMatrix=t.groupTransform,e.uniforms.uRound=this.renderer._roundPixels|t._roundPixels,e.update(),$e(t.groupColorAlpha,e.uniforms.uColor,0),this._adaptor.execute(this,t)}_getMeshData(t){return this._meshDataHash[t.uid]||this._initMeshData(t)}_initMeshData(t){var e,r;return this._meshDataHash[t.uid]={batched:t.batched,indexSize:(e=t._geometry.indices)==null?void 0:e.length,vertexSize:(r=t._geometry.positions)==null?void 0:r.length},t.on("destroyed",()=>{this.destroyRenderable(t)}),this._meshDataHash[t.uid]}_getBatchableMesh(t){return this._gpuBatchableMeshHash[t.uid]||this._initBatchableMesh(t)}_initBatchableMesh(t){const e=W.get(Ve);return e.mesh=t,e.texture=t._texture,e.roundPixels=this.renderer._roundPixels|t._roundPixels,this._gpuBatchableMeshHash[t.uid]=e,e.mesh=t,e}destroy(){for(const t in this._gpuBatchableMeshHash)this._gpuBatchableMeshHash[t]&&W.return(this._gpuBatchableMeshHash[t]);this._gpuBatchableMeshHash=null,this._meshDataHash=null,this.localUniforms=null,this.localUniformsBindGroup=null,this._adaptor.destroy(),this._adaptor=null,this.renderer=null}}bs.extension={type:[R.WebGLPipes,R.WebGPUPipes,R.CanvasPipes],name:"mesh"};const Ss=class ws extends Vn{constructor(t={}){t={...ws.defaultOptions,...t},super({width:t.width,height:t.height,verticesX:4,verticesY:4}),this.update(t)}update(t){this.width=t.width??this.width,this.height=t.height??this.height,this._originalWidth=t.originalWidth??this._originalWidth,this._originalHeight=t.originalHeight??this._originalHeight,this._leftWidth=t.leftWidth??this._leftWidth,this._rightWidth=t.rightWidth??this._rightWidth,this._topHeight=t.topHeight??this._topHeight,this._bottomHeight=t.bottomHeight??this._bottomHeight,this.updateUvs(),this.updatePositions()}updatePositions(){const t=this.positions,e=this._leftWidth+this._rightWidth,r=this.width>e?1:this.width/e,s=this._topHeight+this._bottomHeight,n=this.height>s?1:this.height/s,a=Math.min(r,n);t[9]=t[11]=t[13]=t[15]=this._topHeight*a,t[17]=t[19]=t[21]=t[23]=this.height-this._bottomHeight*a,t[25]=t[27]=t[29]=t[31]=this.height,t[2]=t[10]=t[18]=t[26]=this._leftWidth*a,t[4]=t[12]=t[20]=t[28]=this.width-this._rightWidth*a,t[6]=t[14]=t[22]=t[30]=this.width,this.getBuffer("aPosition").update()}updateUvs(){const t=this.uvs;t[0]=t[8]=t[16]=t[24]=0,t[1]=t[3]=t[5]=t[7]=0,t[6]=t[14]=t[22]=t[30]=1,t[25]=t[27]=t[29]=t[31]=1;const e=1/this._originalWidth,r=1/this._originalHeight;t[2]=t[10]=t[18]=t[26]=e*this._leftWidth,t[9]=t[11]=t[13]=t[15]=r*this._topHeight,t[4]=t[12]=t[20]=t[28]=1-e*this._rightWidth,t[17]=t[19]=t[21]=t[23]=1-r*this._bottomHeight,this.getBuffer("aUV").update()}};Ss.defaultOptions={width:100,height:100,leftWidth:10,topHeight:10,rightWidth:10,bottomHeight:10,originalWidth:100,originalHeight:100};let Nn=Ss;class Ts{constructor(t){this._gpuSpriteHash=Object.create(null),this._renderer=t}addRenderable(t,e){const r=this._getGpuSprite(t);t._didSpriteUpdate&&this._updateBatchableSprite(t,r),this._renderer.renderPipes.batch.addToBatch(r)}updateRenderable(t){const e=this._gpuSpriteHash[t.uid];t._didSpriteUpdate&&this._updateBatchableSprite(t,e),e.batcher.updateElement(e)}validateRenderable(t){const e=t._texture,r=this._getGpuSprite(t);return r.texture._source!==e._source?!r.batcher.checkAndUpdateTexture(r,e):!1}destroyRenderable(t){const e=this._gpuSpriteHash[t.uid];W.return(e),this._gpuSpriteHash[t.uid]=null}_updateBatchableSprite(t,e){t._didSpriteUpdate=!1,e.geometry.update(t),e.texture=t._texture}_getGpuSprite(t){return this._gpuSpriteHash[t.uid]||this._initGPUSprite(t)}_initGPUSprite(t){const e=new Ve;return e.geometry=new Nn,e.mesh=t,e.texture=t._texture,e.roundPixels=this._renderer._roundPixels|t._roundPixels,this._gpuSpriteHash[t.uid]=e,t.on("destroyed",()=>{this.destroyRenderable(t)}),e}destroy(){for(const t in this._gpuSpriteHash)this._gpuSpriteHash[t].geometry.destroy();this._gpuSpriteHash=null,this._renderer=null}}Ts.extension={type:[R.WebGLPipes,R.WebGPUPipes,R.CanvasPipes],name:"nineSliceSprite"};const jn={name:"tiling-bit",vertex:{header:`
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,main:`
            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;

            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;
        `},fragment:{header:`
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,main:`

            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);
            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;
            var unclamped = coord;
            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);

            var bias = 0.;

            if(unclamped.x == coord.x && unclamped.y == coord.y)
            {
                bias = -32.;
            } 

            outColor = textureSampleBias(uTexture, uSampler, coord, bias);
        `}},Yn={name:"tiling-bit",vertex:{header:`
            uniform mat3 uTextureTransform;
            uniform vec4 uSizeAnchor;
        
        `,main:`
            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;
        `},fragment:{header:`
            uniform sampler2D uTexture;
            uniform mat3 uMapCoord;
            uniform vec4 uClampFrame;
            uniform vec2 uClampOffset;
        `,main:`

        vec2 coord = vUV + ceil(uClampOffset - vUV);
        coord = (uMapCoord * vec3(coord, 1.0)).xy;
        vec2 unclamped = coord;
        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);
        
        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0
    
        `}};let _e,ye;class Xn extends qt{constructor(){_e??(_e=us({name:"tiling-sprite-shader",bits:[Vt,jn,fs]})),ye??(ye=ds({name:"tiling-sprite-shader",bits:[$n,Yn,ps]}));const t=new mt({uMapCoord:{value:new V,type:"mat3x3<f32>"},uClampFrame:{value:new Float32Array([0,0,1,1]),type:"vec4<f32>"},uClampOffset:{value:new Float32Array([0,0]),type:"vec2<f32>"},uTextureTransform:{value:new V,type:"mat3x3<f32>"},uSizeAnchor:{value:new Float32Array([100,100,.5,.5]),type:"vec4<f32>"}});super({glProgram:ye,gpuProgram:_e,resources:{localUniforms:new mt({uTransformMatrix:{value:new V,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}}),tilingUniforms:t,uTexture:O.EMPTY.source,uSampler:O.EMPTY.source.style}})}updateUniforms(t,e,r,s,n,a){const o=this.resources.tilingUniforms,h=a.width,l=a.height,c=a.textureMatrix,u=o.uniforms.uTextureTransform;u.set(r.a*h/t,r.b*h/e,r.c*l/t,r.d*l/e,r.tx/t,r.ty/e),u.invert(),o.uniforms.uMapCoord=c.mapCoord,o.uniforms.uClampFrame=c.uClampFrame,o.uniforms.uClampOffset=c.uClampOffset,o.uniforms.uTextureTransform=u,o.uniforms.uSizeAnchor[0]=t,o.uniforms.uSizeAnchor[1]=e,o.uniforms.uSizeAnchor[2]=s,o.uniforms.uSizeAnchor[3]=n,a&&(this.resources.uTexture=a.source,this.resources.uSampler=a.source.style)}}class qn extends Le{constructor(){super({positions:new Float32Array([0,0,1,0,1,1,0,1]),uvs:new Float32Array([0,0,1,0,1,1,0,1]),indices:new Uint32Array([0,1,2,0,2,3])})}}function Kn(i,t){const e=i.anchor.x,r=i.anchor.y;t[0]=-e*i.width,t[1]=-r*i.height,t[2]=(1-e)*i.width,t[3]=-r*i.height,t[4]=(1-e)*i.width,t[5]=(1-r)*i.height,t[6]=-e*i.width,t[7]=(1-r)*i.height}function Qn(i,t,e,r){let s=0;const n=i.length/t,a=r.a,o=r.b,h=r.c,l=r.d,c=r.tx,u=r.ty;for(e*=t;s<n;){const f=i[e],p=i[e+1];i[e]=a*f+h*p+c,i[e+1]=o*f+l*p+u,e+=t,s++}}function Zn(i,t){const e=i.texture,r=e.frame.width,s=e.frame.height;let n=0,a=0;i._applyAnchorToTexture&&(n=i.anchor.x,a=i.anchor.y),t[0]=t[6]=-n,t[2]=t[4]=1-n,t[1]=t[3]=-a,t[5]=t[7]=1-a;const o=V.shared;o.copyFrom(i._tileTransform.matrix),o.tx/=i.width,o.ty/=i.height,o.invert(),o.scale(i.width/r,i.height/s),Qn(t,2,0,o)}const Ot=new qn;class vs{constructor(t){this._tilingSpriteDataHash=Object.create(null),this._renderer=t}validateRenderable(t){const e=this._getTilingSpriteData(t),r=e.canBatch;this._updateCanBatch(t);const s=e.canBatch;if(s&&s===r){const{batchableMesh:n}=e;if(n.texture._source!==t.texture._source)return!n.batcher.checkAndUpdateTexture(n,t.texture)}return r!==s}addRenderable(t,e){const r=this._renderer.renderPipes.batch;this._updateCanBatch(t);const s=this._getTilingSpriteData(t),{geometry:n,canBatch:a}=s;if(a){s.batchableMesh||(s.batchableMesh=new Ve);const o=s.batchableMesh;t._didTilingSpriteUpdate&&(t._didTilingSpriteUpdate=!1,this._updateBatchableMesh(t),o.geometry=n,o.mesh=t,o.texture=t._texture),o.roundPixels=this._renderer._roundPixels|t._roundPixels,r.addToBatch(o)}else r.break(e),s.shader||(s.shader=new Xn),this.updateRenderable(t),e.add(t)}execute(t){const{shader:e}=this._tilingSpriteDataHash[t.uid];e.groups[0]=this._renderer.globalUniforms.bindGroup;const r=e.resources.localUniforms.uniforms;r.uTransformMatrix=t.groupTransform,r.uRound=this._renderer._roundPixels|t._roundPixels,$e(t.groupColorAlpha,r.uColor,0),this._renderer.encoder.draw({geometry:Ot,shader:e,state:Ur.default2d})}updateRenderable(t){const e=this._getTilingSpriteData(t),{canBatch:r}=e;if(r){const{batchableMesh:s}=e;t._didTilingSpriteUpdate&&this._updateBatchableMesh(t),s.batcher.updateElement(s)}else if(t._didTilingSpriteUpdate){const{shader:s}=e;s.updateUniforms(t.width,t.height,t._tileTransform.matrix,t.anchor.x,t.anchor.y,t.texture)}t._didTilingSpriteUpdate=!1}destroyRenderable(t){var r;const e=this._getTilingSpriteData(t);e.batchableMesh=null,(r=e.shader)==null||r.destroy(),this._tilingSpriteDataHash[t.uid]=null}_getTilingSpriteData(t){return this._tilingSpriteDataHash[t.uid]||this._initTilingSpriteData(t)}_initTilingSpriteData(t){const e=new Le({indices:Ot.indices,positions:Ot.positions.slice(),uvs:Ot.uvs.slice()});return this._tilingSpriteDataHash[t.uid]={canBatch:!0,renderable:t,geometry:e},t.on("destroyed",()=>{this.destroyRenderable(t)}),this._tilingSpriteDataHash[t.uid]}_updateBatchableMesh(t){const e=this._getTilingSpriteData(t),{geometry:r}=e,s=t.texture.source.style;s.addressMode!=="repeat"&&(s.addressMode="repeat",s.update()),Zn(t,r.uvs),Kn(t,r.positions)}destroy(){for(const t in this._tilingSpriteDataHash)this.destroyRenderable(this._tilingSpriteDataHash[t].renderable);this._tilingSpriteDataHash=null,this._renderer=null}_updateCanBatch(t){const e=this._getTilingSpriteData(t),r=t.texture;let s=!0;return this._renderer.type===St.WEBGL&&(s=this._renderer.context.supports.nonPowOf2wrapping),e.canBatch=r.textureMatrix.isSimple&&(s||r.source.isPowerOfTwo),e.canBatch}}vs.extension={type:[R.WebGLPipes,R.WebGPUPipes,R.CanvasPipes],name:"tilingSprite"};const be={test(i){return typeof i=="string"&&i.startsWith("info face=")},parse(i){const t=i.match(/^[a-z]+\s+.+$/gm),e={info:[],common:[],page:[],char:[],chars:[],kerning:[],kernings:[],distanceField:[]};for(const u in t){const f=t[u].match(/^[a-z]+/gm)[0],p=t[u].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm),d={};for(const x in p){const g=p[x].split("="),_=g[0],m=g[1].replace(/"/gm,""),y=parseFloat(m),b=isNaN(y)?m:y;d[_]=b}e[f].push(d)}const r={chars:{},pages:[],lineHeight:0,fontSize:0,fontFamily:"",distanceField:null,baseLineOffset:0},[s]=e.info,[n]=e.common,[a]=e.distanceField??[];a&&(r.distanceField={range:parseInt(a.distanceRange,10),type:a.fieldType}),r.fontSize=parseInt(s.size,10),r.fontFamily=s.face,r.lineHeight=parseInt(n.lineHeight,10);const o=e.page;for(let u=0;u<o.length;u++)r.pages.push({id:parseInt(o[u].id,10)||0,file:o[u].file});const h={};r.baseLineOffset=r.lineHeight-parseInt(n.base,10);const l=e.char;for(let u=0;u<l.length;u++){const f=l[u],p=parseInt(f.id,10);let d=f.letter??f.char??String.fromCharCode(p);d==="space"&&(d=" "),h[p]=d,r.chars[d]={id:p,page:parseInt(f.page,10)||0,x:parseInt(f.x,10),y:parseInt(f.y,10),width:parseInt(f.width,10),height:parseInt(f.height,10),xOffset:parseInt(f.xoffset,10),yOffset:parseInt(f.yoffset,10),xAdvance:parseInt(f.xadvance,10),kerning:{}}}const c=e.kerning||[];for(let u=0;u<c.length;u++){const f=parseInt(c[u].first,10),p=parseInt(c[u].second,10),d=parseInt(c[u].amount,10);r.chars[h[p]].kerning[h[f]]=d}return r}},Tr={test(i){const t=i;return typeof t!="string"&&"getElementsByTagName"in t&&t.getElementsByTagName("page").length&&t.getElementsByTagName("info")[0].getAttribute("face")!==null},parse(i){const t={chars:{},pages:[],lineHeight:0,fontSize:0,fontFamily:"",distanceField:null,baseLineOffset:0},e=i.getElementsByTagName("info")[0],r=i.getElementsByTagName("common")[0],s=i.getElementsByTagName("distanceField")[0];s&&(t.distanceField={type:s.getAttribute("fieldType"),range:parseInt(s.getAttribute("distanceRange"),10)});const n=i.getElementsByTagName("page"),a=i.getElementsByTagName("char"),o=i.getElementsByTagName("kerning");t.fontSize=parseInt(e.getAttribute("size"),10),t.fontFamily=e.getAttribute("face"),t.lineHeight=parseInt(r.getAttribute("lineHeight"),10);for(let l=0;l<n.length;l++)t.pages.push({id:parseInt(n[l].getAttribute("id"),10)||0,file:n[l].getAttribute("file")});const h={};t.baseLineOffset=t.lineHeight-parseInt(r.getAttribute("base"),10);for(let l=0;l<a.length;l++){const c=a[l],u=parseInt(c.getAttribute("id"),10);let f=c.getAttribute("letter")??c.getAttribute("char")??String.fromCharCode(u);f==="space"&&(f=" "),h[u]=f,t.chars[f]={id:u,page:parseInt(c.getAttribute("page"),10)||0,x:parseInt(c.getAttribute("x"),10),y:parseInt(c.getAttribute("y"),10),width:parseInt(c.getAttribute("width"),10),height:parseInt(c.getAttribute("height"),10),xOffset:parseInt(c.getAttribute("xoffset"),10),yOffset:parseInt(c.getAttribute("yoffset"),10),xAdvance:parseInt(c.getAttribute("xadvance"),10),kerning:{}}}for(let l=0;l<o.length;l++){const c=parseInt(o[l].getAttribute("first"),10),u=parseInt(o[l].getAttribute("second"),10),f=parseInt(o[l].getAttribute("amount"),10);t.chars[h[u]].kerning[h[c]]=f}return t}},vr={test(i){return typeof i=="string"&&i.includes("<font>")?Tr.test(q.get().parseXML(i)):!1},parse(i){return Tr.parse(q.get().parseXML(i))}};class Ps extends ss{constructor(t,e){super();const{textures:r,data:s}=t;Object.keys(s.pages).forEach(n=>{const a=s.pages[parseInt(n,10)],o=r[a.id];this.pages.push({texture:o})}),Object.keys(s.chars).forEach(n=>{const a=s.chars[n],{frame:o,source:h}=r[a.page],l=new Q(a.x+o.x,a.y+o.y,a.width,a.height),c=new O({source:h,frame:l});this.chars[n]={id:n.codePointAt(0),xOffset:a.xOffset,yOffset:a.yOffset,xAdvance:a.xAdvance,kerning:a.kerning??{},texture:c}}),this.baseRenderedFontSize=s.fontSize,this.baseMeasurementFontSize=s.fontSize,this.fontMetrics={ascent:0,descent:0,fontSize:s.fontSize},this.baseLineOffset=s.baseLineOffset,this.lineHeight=s.lineHeight,this.fontFamily=s.fontFamily,this.distanceField=s.distanceField??{type:"none",range:0},this.url=e}destroy(){super.destroy();for(let t=0;t<this.pages.length;t++){const{texture:e}=this.pages[t];e.destroy(!0)}this.pages=null}static install(t){ke.install(t)}static uninstall(t){ke.uninstall(t)}}const Jn=[".xml",".fnt"],ta={extension:R.CacheParser,test:i=>i instanceof Ps,getCacheableAssets(i,t){const e={};return i.forEach(r=>{e[r]=t}),e[`${t.fontFamily}-bitmap`]=t,e}},ea={extension:{type:R.LoadParser,priority:Ls.Normal},test(i){return Jn.includes(Zt.extname(i).toLowerCase())},async testParse(i){return be.test(i)||vr.test(i)},async parse(i,t,e){const r=be.test(i)?be.parse(i):vr.parse(i),{src:s}=t,{pages:n}=r,a=[];for(let c=0;c<n.length;++c){const u=n[c].file;let f=Zt.join(Zt.dirname(s),u);f=Hs(f,s),a.push(f)}const o=await e.load(a),h=a.map(c=>o[c]);return new Ps({data:r,textures:h},s)},async load(i,t){return await(await q.get().fetch(i)).text()},async unload(i,t,e){await Promise.all(i.pages.map(r=>e.unload(r.texture.source._sourceOrigin))),i.destroy()}},ra={name:"local-uniform-msdf-bit",vertex:{header:`
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32,
                uRound:f32,
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,main:`
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,end:`
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `},fragment:{header:`
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
         `,main:` 
            outColor = vColor * calculateMSDFAlpha(outColor, localUniforms.uDistance);
        `}},sa={name:"local-uniform-msdf-bit",vertex:{header:`
            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,main:`
            vColor *= uColor;
            modelMatrix *= uTransformMatrix;
        `,end:`
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `},fragment:{header:`
            uniform float uDistance;
         `,main:` 
            outColor = vColor * calculateMSDFAlpha(outColor, uDistance);
        `}},ia={name:"msdf-bit",fragment:{header:`
            fn calculateMSDFAlpha(msdfColor:vec4<f32>, distance:f32) -> f32 {
                
                // MSDF
                var median = msdfColor.r + msdfColor.g + msdfColor.b -
                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));
            
                // SDF
                median = min(median, msdfColor.a);

                var screenPxDistance = distance * (median - 0.5);
                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                return alpha;
            }
        `}},na={name:"msdf-bit",fragment:{header:`
            float calculateMSDFAlpha(vec4 msdfColor, float distance) {
                
                // MSDF
                float median = msdfColor.r + msdfColor.g + msdfColor.b -
                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));
               
                // SDF
                median = min(median, msdfColor.a);
            
                float screenPxDistance = distance * (median - 0.5);
                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
           
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                return alpha;
            }
        `}};class aa extends qt{constructor(){const t=new mt({uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uTransformMatrix:{value:new V,type:"mat3x3<f32>"},uDistance:{value:4,type:"f32"},uRound:{value:0,type:"f32"}}),e=us({name:"sdf-shader",bits:[Gn,Wn(et),ra,ia,fs]}),r=ds({name:"sdf-shader",bits:[Un,Hn(et),sa,na,ps]});super({glProgram:r,gpuProgram:e,resources:{localUniforms:t,batchSamplers:On}})}}class Cs{constructor(t){this._gpuBitmapText={},this._renderer=t}validateRenderable(t){const e=this._getGpuBitmapText(t);return t._didTextUpdate&&(t._didTextUpdate=!1,this._updateContext(t,e)),this._renderer.renderPipes.graphics.validateRenderable(e)}addRenderable(t,e){const r=this._getGpuBitmapText(t);Pr(t,r),t._didTextUpdate&&(t._didTextUpdate=!1,this._updateContext(t,r)),this._renderer.renderPipes.graphics.addRenderable(r,e),r.context.customShader&&this._updateDistanceField(t)}destroyRenderable(t){this._destroyRenderableByUid(t.uid)}_destroyRenderableByUid(t){W.return(this._gpuBitmapText[t]),this._gpuBitmapText[t]=null}updateRenderable(t){const e=this._getGpuBitmapText(t);Pr(t,e),this._renderer.renderPipes.graphics.updateRenderable(e),e.context.customShader&&this._updateDistanceField(t)}_updateContext(t,e){var p;const{context:r}=e,s=ke.getFont(t.text,t._style);r.clear(),s.distanceField.type!=="none"&&(r.customShader||(this._sdfShader||(this._sdfShader=new aa),r.customShader=this._sdfShader));const n=Array.from(t.text),a=t._style;let o=(((p=a._stroke)==null?void 0:p.width)||0)/2;o+=s.baseLineOffset;const h=ns(n,a,s);let l=0;const c=a.padding,u=h.scale;r.translate(-t._anchor._x*h.width-c,-t._anchor._y*(h.height+h.offsetY)-c).scale(u,u);const f=a._fill.color;for(let d=0;d<h.lines.length;d++){const x=h.lines[d];for(let g=0;g<x.charPositions.length;g++){const _=n[l++],m=s.chars[_];m!=null&&m.texture&&r.texture(m.texture,f||"black",Math.round(x.charPositions[g]+m.xOffset),Math.round(o+m.yOffset))}o+=s.lineHeight}}_getGpuBitmapText(t){return this._gpuBitmapText[t.uid]||this.initGpuText(t)}initGpuText(t){const e=W.get(Nt);return this._gpuBitmapText[t.uid]=e,this._updateContext(t,e),t.on("destroyed",()=>{this.destroyRenderable(t)}),this._gpuBitmapText[t.uid]}_updateDistanceField(t){const e=this._getGpuBitmapText(t).context,r=t._style.fontFamily,s=X.get(`${r}-bitmap`),{a:n,b:a,c:o,d:h}=t.groupTransform,l=Math.sqrt(n*n+a*a),c=Math.sqrt(o*o+h*h),u=(Math.abs(l)+Math.abs(c))/2,f=s.baseRenderedFontSize/t._style.fontSize,p=t.resolution??this._renderer.resolution,d=u*s.distanceField.range*(1/f)*p;e.customShader.resources.localUniforms.uniforms.uDistance=d}destroy(){var t;for(const e in this._gpuBitmapText)this._destroyRenderableByUid(e);this._gpuBitmapText=null,(t=this._sdfShader)==null||t.destroy(!0),this._sdfShader=null,this._renderer=null}}Cs.extension={type:[R.WebGLPipes,R.WebGPUPipes,R.CanvasPipes],name:"bitmapText"};function Pr(i,t){t.groupTransform=i.groupTransform,t.groupColorAlpha=i.groupColorAlpha,t.groupColor=i.groupColor,t.groupBlendMode=i.groupBlendMode,t.globalDisplayStatus=i.globalDisplayStatus,t.groupTransform=i.groupTransform,t.localDisplayStatus=i.localDisplayStatus,t.groupAlpha=i.groupAlpha,t._roundPixels=i._roundPixels}class Ms{constructor(t){this._gpuText=Object.create(null),this._renderer=t}validateRenderable(t){const e=this._getGpuText(t),r=t._getKey();return e.textureNeedsUploading?(e.textureNeedsUploading=!1,!0):e.currentKey!==r}addRenderable(t){const r=this._getGpuText(t).batchableSprite;t._didTextUpdate&&this._updateText(t),this._renderer.renderPipes.batch.addToBatch(r)}updateRenderable(t){const r=this._getGpuText(t).batchableSprite;t._didTextUpdate&&this._updateText(t),r.batcher.updateElement(r)}destroyRenderable(t){this._destroyRenderableById(t.uid)}_destroyRenderableById(t){const e=this._gpuText[t];this._renderer.htmlText.decreaseReferenceCount(e.currentKey),W.return(e.batchableSprite),this._gpuText[t]=null}_updateText(t){const e=t._getKey(),r=this._getGpuText(t),s=r.batchableSprite;r.currentKey!==e&&this._updateGpuText(t).catch(a=>{console.error(a)}),t._didTextUpdate=!1;const n=t._style.padding;Se(s.bounds,t._anchor,s.texture,n)}async _updateGpuText(t){t._didTextUpdate=!1;const e=this._getGpuText(t);if(e.generatingTexture)return;const r=t._getKey();this._renderer.htmlText.decreaseReferenceCount(e.currentKey),e.generatingTexture=!0,e.currentKey=r;const s=t.resolution??this._renderer.resolution,n=await this._renderer.htmlText.getManagedTexture(t.text,s,t._style,t._getKey()),a=e.batchableSprite;a.texture=e.texture=n,e.generatingTexture=!1,e.textureNeedsUploading=!0,t.onViewUpdate();const o=t._style.padding;Se(a.bounds,t._anchor,a.texture,o)}_getGpuText(t){return this._gpuText[t.uid]||this.initGpuText(t)}initGpuText(t){const e={texture:O.EMPTY,currentKey:"--",batchableSprite:W.get(ms),textureNeedsUploading:!1,generatingTexture:!1},r=e.batchableSprite;return r.renderable=t,r.texture=O.EMPTY,r.bounds={minX:0,maxX:1,minY:0,maxY:0},r.roundPixels=this._renderer._roundPixels|t._roundPixels,this._gpuText[t.uid]=e,t.on("destroyed",()=>{this.destroyRenderable(t)}),e}destroy(){for(const t in this._gpuText)this._destroyRenderableById(t);this._gpuText=null,this._renderer=null}}Ms.extension={type:[R.WebGLPipes,R.WebGPUPipes,R.CanvasPipes],name:"htmlText"};function oa(){const{userAgent:i}=q.get().getNavigator();return/^((?!chrome|android).)*safari/i.test(i)}const ha=new Gt;function ks(i,t,e,r){const s=ha;s.minX=0,s.minY=0,s.maxX=i.width/r|0,s.maxY=i.height/r|0;const n=tt.getOptimalTexture(s.width,s.height,r,!1);return n.source.uploadMethodId="image",n.source.resource=i,n.source.alphaMode="premultiply-alpha-on-upload",n.frame.width=t/r,n.frame.height=e/r,n.source.emit("update",n.source),n.updateUvs(),n}function ca(i,t){const e=t.fontFamily,r=[],s={},n=/font-family:([^;"\s]+)/g,a=i.match(n);function o(h){s[h]||(r.push(h),s[h]=!0)}if(Array.isArray(e))for(let h=0;h<e.length;h++)o(e[h]);else o(e);a&&a.forEach(h=>{const l=h.split(":")[1].trim();o(l)});for(const h in t.tagStyles){const l=t.tagStyles[h].fontFamily;o(l)}return r}async function la(i){const e=await(await q.get().fetch(i)).blob(),r=new FileReader;return await new Promise((n,a)=>{r.onloadend=()=>n(r.result),r.onerror=a,r.readAsDataURL(e)})}async function Cr(i,t){const e=await la(t);return`@font-face {
        font-family: "${i.fontFamily}";
        src: url('${e}');
        font-weight: ${i.fontWeight};
        font-style: ${i.fontStyle};
    }`}const $t=new Map;async function ua(i,t,e){const r=i.filter(s=>X.has(`${s}-and-url`)).map((s,n)=>{if(!$t.has(s)){const{url:a}=X.get(`${s}-and-url`);n===0?$t.set(s,Cr(t,a)):$t.set(s,Cr({fontWeight:e.fontWeight,fontStyle:e.fontStyle,fontFamily:s},a))}return $t.get(s)});return(await Promise.all(r)).join(`
`)}function da(i,t,e,r,s){const{domElement:n,styleElement:a,svgRoot:o}=s;n.innerHTML=`<style>${t.cssStyle}</style><div>${i}</div>`,n.setAttribute("style",`transform: scale(${e});transform-origin: top left; display: inline-block`),a.textContent=r;const{width:h,height:l}=s.image;return o.setAttribute("width",h.toString()),o.setAttribute("height",l.toString()),new XMLSerializer().serializeToString(o)}function fa(i,t){const e=pt.getOptimalCanvasAndContext(i.width,i.height,t),{context:r}=e;return r.clearRect(0,0,i.width,i.height),r.drawImage(i,0,0),pt.returnCanvasAndContext(e),e.canvas}function pa(i,t,e){return new Promise(async r=>{e&&await new Promise(s=>setTimeout(s,100)),i.onload=()=>{r()},i.src=`data:image/svg+xml;charset=utf8,${encodeURIComponent(t)}`,i.crossOrigin="anonymous"})}class Ne{constructor(t){this._activeTextures={},this._renderer=t,this._createCanvas=t.type===St.WEBGPU}getTexture(t){return this._buildTexturePromise(t.text,t.resolution,t.style)}getManagedTexture(t,e,r,s){if(this._activeTextures[s])return this._increaseReferenceCount(s),this._activeTextures[s].promise;const n=this._buildTexturePromise(t,e,r).then(a=>(this._activeTextures[s].texture=a,a));return this._activeTextures[s]={texture:null,promise:n,usageCount:1},n}async _buildTexturePromise(t,e,r){const s=W.get(hs),n=ca(t,r),a=await ua(n,r,Oe.defaultTextStyle),o=bn(t,r,a,s),h=Math.ceil(Math.ceil(Math.max(1,o.width)+r.padding*2)*e),l=Math.ceil(Math.ceil(Math.max(1,o.height)+r.padding*2)*e),c=s.image;c.width=h|0,c.height=l|0;const u=da(t,r,e,a,s);await pa(c,u,oa()&&n.length>0);let f=c;this._createCanvas&&(f=fa(c,e));const p=ks(f,c.width,c.height,e);return this._createCanvas&&this._renderer.texture.initSource(p.source),W.return(s),p}_increaseReferenceCount(t){this._activeTextures[t].usageCount++}decreaseReferenceCount(t){const e=this._activeTextures[t];e&&(e.usageCount--,e.usageCount===0&&(e.texture?this._cleanUp(e):e.promise.then(r=>{e.texture=r,this._cleanUp(e)}).catch(()=>{ot("HTMLTextSystem: Failed to clean texture")}),this._activeTextures[t]=null))}_cleanUp(t){tt.returnTexture(t.texture),t.texture.source.resource=null,t.texture.source.uploadMethodId="unknown"}getReferenceCount(t){return this._activeTextures[t].usageCount}destroy(){this._activeTextures=null}}Ne.extension={type:[R.WebGLSystem,R.WebGPUSystem,R.CanvasSystem],name:"htmlText"};Ne.defaultFontOptions={fontFamily:"Arial",fontStyle:"normal",fontWeight:"normal"};class Bs{constructor(t){this._gpuText=Object.create(null),this._renderer=t}validateRenderable(t){const e=this._getGpuText(t),r=t._getKey();if(e.currentKey!==r){const s=t.resolution??this._renderer.resolution,{width:n,height:a}=this._renderer.canvasText.getTextureSize(t.text,s,t._style);return!(this._renderer.canvasText.getReferenceCount(e.currentKey)===1&&n===e.texture._source.width&&a===e.texture._source.height)}return!1}addRenderable(t,e){const s=this._getGpuText(t).batchableSprite;t._didTextUpdate&&this._updateText(t),this._renderer.renderPipes.batch.addToBatch(s)}updateRenderable(t){const r=this._getGpuText(t).batchableSprite;t._didTextUpdate&&this._updateText(t),r.batcher.updateElement(r)}destroyRenderable(t){this._destroyRenderableById(t.uid)}_destroyRenderableById(t){const e=this._gpuText[t];this._renderer.canvasText.decreaseReferenceCount(e.currentKey),W.return(e.batchableSprite),this._gpuText[t]=null}_updateText(t){const e=t._getKey(),r=this._getGpuText(t),s=r.batchableSprite;r.currentKey!==e&&this._updateGpuText(t),t._didTextUpdate=!1;const n=t._style.padding;Se(s.bounds,t._anchor,s.texture,n)}_updateGpuText(t){const e=this._getGpuText(t),r=e.batchableSprite;e.texture&&this._renderer.canvasText.decreaseReferenceCount(e.currentKey),e.texture=r.texture=this._renderer.canvasText.getManagedTexture(t),e.currentKey=t._getKey(),r.texture=e.texture}_getGpuText(t){return this._gpuText[t.uid]||this.initGpuText(t)}initGpuText(t){const e={texture:null,currentKey:"--",batchableSprite:W.get(ms)};return e.batchableSprite.renderable=t,e.batchableSprite.bounds={minX:0,maxX:1,minY:0,maxY:0},e.batchableSprite.roundPixels=this._renderer._roundPixels|t._roundPixels,this._gpuText[t.uid]=e,this._updateText(t),t.on("destroyed",()=>{this.destroyRenderable(t)}),e}destroy(){for(const t in this._gpuText)this._destroyRenderableById(t);this._gpuText=null,this._renderer=null}}Bs.extension={type:[R.WebGLPipes,R.WebGPUPipes,R.CanvasPipes],name:"text"};function Mr(i,t,e){for(let r=0,s=4*e*t;r<t;++r,s+=4)if(i[s+3]!==0)return!1;return!0}function kr(i,t,e,r,s){const n=4*t;for(let a=r,o=r*n+4*e;a<=s;++a,o+=n)if(i[o+3]!==0)return!1;return!0}function ga(i,t=1){const{width:e,height:r}=i,s=i.getContext("2d",{willReadFrequently:!0});if(s===null)throw new TypeError("Failed to get canvas 2D context");const a=s.getImageData(0,0,e,r).data;let o=0,h=0,l=e-1,c=r-1;for(;h<r&&Mr(a,e,h);)++h;if(h===r)return Q.EMPTY;for(;Mr(a,e,c);)--c;for(;kr(a,e,o,h,c);)++o;for(;kr(a,e,l,h,c);)--l;return++l,++c,new Q(o/t,h/t,(l-o)/t,(c-h)/t)}class As{constructor(t){this._activeTextures={},this._renderer=t}getTextureSize(t,e,r){const s=rt.measureText(t||" ",r);let n=Math.ceil(Math.ceil(Math.max(1,s.width)+r.padding*2)*e),a=Math.ceil(Math.ceil(Math.max(1,s.height)+r.padding*2)*e);return n=Math.ceil(n-1e-6),a=Math.ceil(a-1e-6),n=bt(n),a=bt(a),{width:n,height:a}}getTexture(t,e,r,s){typeof t=="string"&&(E("8.0.0","CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments"),t={text:t,style:r,resolution:e}),t.style instanceof Tt||(t.style=new Tt(t.style));const{texture:n,canvasAndContext:a}=this.createTextureAndCanvas(t);return this._renderer.texture.initSource(n._source),pt.returnCanvasAndContext(a),n}createTextureAndCanvas(t){const{text:e,style:r}=t,s=t.resolution??this._renderer.resolution,n=rt.measureText(e||" ",r),a=Math.ceil(Math.ceil(Math.max(1,n.width)+r.padding*2)*s),o=Math.ceil(Math.ceil(Math.max(1,n.height)+r.padding*2)*s),h=pt.getOptimalCanvasAndContext(a,o),{canvas:l}=h;this.renderTextToCanvas(e,r,s,h);const c=ks(l,a,o,s);if(r.trim){const u=ga(l,s);c.frame.copyFrom(u),c.updateUvs()}return{texture:c,canvasAndContext:h}}getManagedTexture(t){const e=t._getKey();if(this._activeTextures[e])return this._increaseReferenceCount(e),this._activeTextures[e].texture;const{texture:r,canvasAndContext:s}=this.createTextureAndCanvas(t);return this._activeTextures[e]={canvasAndContext:s,texture:r,usageCount:1},r}_increaseReferenceCount(t){this._activeTextures[t].usageCount++}decreaseReferenceCount(t){const e=this._activeTextures[t];if(e.usageCount--,e.usageCount===0){pt.returnCanvasAndContext(e.canvasAndContext),tt.returnTexture(e.texture);const r=e.texture.source;r.resource=null,r.uploadMethodId="unknown",r.alphaMode="no-premultiply-alpha",this._activeTextures[t]=null}}getReferenceCount(t){return this._activeTextures[t].usageCount}renderTextToCanvas(t,e,r,s){var y,b,P,k,T;const{canvas:n,context:a}=s,o=jt(e),h=rt.measureText(t||" ",e),l=h.lines,c=h.lineHeight,u=h.lineWidths,f=h.maxLineWidth,p=h.fontProperties,d=n.height;a.resetTransform(),a.scale(r,r);const x=e.padding*2;if(a.clearRect(0,0,h.width+4+x,h.height+4+x),(y=e._stroke)!=null&&y.width){const v=e._stroke;a.lineWidth=v.width,a.miterLimit=v.miterLimit,a.lineJoin=v.join,a.lineCap=v.cap}a.font=o;let g,_;const m=e.dropShadow?2:1;for(let v=0;v<m;++v){const S=e.dropShadow&&v===0,w=S?Math.ceil(Math.max(1,d)+e.padding*2):0,G=w*r;if(S){a.fillStyle="black",a.strokeStyle="black";const C=e.dropShadow,I=C.color,U=C.alpha;a.shadowColor=H.shared.setValue(I).setAlpha(U).toRgbaString();const j=C.blur*r,Pt=C.distance*r;a.shadowBlur=j,a.shadowOffsetX=Math.cos(C.angle)*Pt,a.shadowOffsetY=Math.sin(C.angle)*Pt+G}else a.globalAlpha=((b=e._fill)==null?void 0:b.alpha)??1,a.fillStyle=e._fill?Yt(e._fill,a):null,(P=e._stroke)!=null&&P.width&&(a.strokeStyle=Yt(e._stroke,a)),a.shadowColor="black";let Y=(c-p.fontSize)/2;c-p.fontSize<0&&(Y=0);const B=((k=e._stroke)==null?void 0:k.width)??0;for(let C=0;C<l.length;C++)g=B/2,_=B/2+C*c+p.ascent+Y,e.align==="right"?g+=f-u[C]:e.align==="center"&&(g+=(f-u[C])/2),(T=e._stroke)!=null&&T.width&&this._drawLetterSpacing(l[C],e,s,g+e.padding,_+e.padding-w,!0),e._fill!==void 0&&this._drawLetterSpacing(l[C],e,s,g+e.padding,_+e.padding-w)}}_drawLetterSpacing(t,e,r,s,n,a=!1){const{context:o}=r,h=e.letterSpacing;let l=!1;if(rt.experimentalLetterSpacingSupported&&(rt.experimentalLetterSpacing?(o.letterSpacing=`${h}px`,o.textLetterSpacing=`${h}px`,l=!0):(o.letterSpacing="0px",o.textLetterSpacing="0px")),h===0||l){a?o.strokeText(t,s,n):o.fillText(t,s,n);return}let c=s;const u=rt.graphemeSegmenter(t);let f=o.measureText(t).width,p=0;for(let d=0;d<u.length;++d){const x=u[d];a?o.strokeText(x,c,n):o.fillText(x,c,n);let g="";for(let _=d+1;_<u.length;++_)g+=u[_];p=o.measureText(g).width,c+=f-p+h,f=p}}destroy(){this._activeTextures=null}}As.extension={type:[R.WebGLSystem,R.WebGPUSystem,R.CanvasSystem],name:"canvasText"};N.add(Er);N.add(Dr);N.add(xs);N.add(Ee);N.add(bs);N.add(As);N.add(Bs);N.add(Cs,ea,ta);N.add(Ne);N.add(Ms);N.add(vs);N.add(Ts);N.add(Zr);N.add(Kr);
